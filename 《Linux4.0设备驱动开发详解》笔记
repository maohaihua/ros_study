https://www.cnblogs.com/zcjboke/p/5513136.html

第一章：Linux设备驱动概念及基础

1.1. 设备驱动的分类
字符驱动
块驱动
网络驱动
1.2 硬件基础
中央处理器结构的分类：

冯诺依曼：指令和数据合并在一起，数据宽度相同（Intel和arm7）
哈弗：指令和数据分开，可以有不同的数据宽度（arm9-cortex系列）
通用处理器分类：

为控制器(MCU)，又称单片机
微控制器(MPU)
DSP分类：定点DSP和浮点DSP

浮点用硬件来实现，处理速度高于定点
定点DSP只能用定点运算来模拟浮点运算
指令集分类：

精简指令集（RISC）,目标代码大（arm，powerPC，MIPS）
复杂指令集（CISC）,目标代码小
存储器分类： 
ROM:

NOR：类SRAM接口，不需要增加额外的外部电路，程序可芯片内执行，可spi访问
NAND：与CPU需要电路转换，以块方式访问，不可芯片内执行，容量大，价格低
RAM:

DPRM：连个端口同时访问，两套完全独立的数据总线、地址总线和读写控制线，可用于两个处理器间交换数据，速度快，实时性强
CAM：以内容进行寻址的存储器，一种特殊的存储阵列RAM，可执行数据匹配。
FIFO：先进先出，用于数据缓存，同一时刻只能设置为一边输入一边作为输出
PCI总线：

PCI：Intel推出，32位可扩展64位，总线操作与处理器-存储器子系统操作并行，规范独立于微处理器，通用性好，
PCI总线1：PCI-PCI桥的下游
PCI总线0：PCI-PCI总线的上游
PCI配置空间：制造商标识、设备标识、分类码、申请存储器空间、申请IO空间以及中断资源申请·
PCI-E：采用点对点串行链接，每个设备都有自己的专用连接，串行方式传输数据，不需要向整个总线申请宽带
仪器仪表： 
1、示波器

三种模式：自动模式、常规模式以及单次模式
自动模式：根据设定的扫描速率自动进行扫描，当有触发发生时，扫描系统会尽量按照信号的频率进行扫描。不论触发条件是否满足都会进行扫描，都会看到扫描下，对信号的特点不是很了解时候选择这种模式
常规扫描：触发条件满足开始扫描
单次扫描：触发条件满足扫描，但只扫描一次

《Linux4.0设备驱动开发详解》笔记--第二章：Linux内核及内核编程

2.1 Linux内核发展及演变
1991年10月5日 Linus Torvalds创建
五个支柱：Unix系统、Minix系统、GNU计划、POSIX标准和Internet
每2-3个月更新一次大的版本号
2.2 Linux2.6后的内核特点
新的调度器：高负荷下的出色性能，更好的处理器扩展，采用CFS算法，新增调度类：SCHED_DEADLINE，它实现了EDF(最早截止期限优先)算法
内核抢占：提高系统的实时性，增强系统的交互性，但也有不可抢占的空间：中断上下文、软中断上下文和自旋锁的区间，如果打上RT-Preempt补丁，即可支持硬实时。
改进线程模型：采用NPTL（本地POSIX线程库）模型，操作速度极大提高，更加遵循POSIX规范
虚拟化内存变化：融合了r-map（反向映射，通过页结构快速找到页面的映射）技术，改善虚拟内存在一定大小负载下的性能
文件系统：新增基于B树的Btrfs，是下一代的Linux文件系统
音频：高级Linux音频体系结构ALSA取代缺陷很多的OSS，支持USB音频和MIDI设备，并支持双工重放等功能
Linux3.7以后实现一个Linux可以适用于所有的arm系统
2.3 Linux内核组成
2.3.1 Linux内核代码的目录结构

arch：和硬件体系结构相关的代码，每个平台每个目录
block：块设备驱动的I/O调度
crypto：常用加密和散列算法，还有一些压缩以及CRC校验算法
documentation：内核各部分的通用解释和注释
fs：支持的各种文件系统
include：内核API级别的头文件，与系统相关的头文件放在include/linux子目录下
init：内核代码的初始化代码
ipc：进程间通信代码
lib：库文件代码
mm：内存管理代码
script：配置内核的脚本文件
usr：用于打包和压缩的cpio等
2.3.2 内核组成部分

进程调度：多数进程是由用户空间创建，通过系统调用进入内核空间，内核编程是可以启动内核线程来处理并发任务，这些线程没有用户空间
内存管理：控制多个进程安全的共享内存区域，通过MMU完成进程从虚拟空间向物理空间的转换
虚拟文件系统：隐藏各个硬件的具体细节，为所有的设备提供了统一的接口，是文件系统的抽象
网络接口：对各种网络标标准的存取和各种网络硬件的支持，分为网络协议和网络驱动程序
进程间通信：信号量、共享内存、消息队列、管道以及Unix域套接字等
2.3.3 内核空间和用户空间

内核可以进行任何操作，但应用程序被禁止对硬件的直接访问和对内存的未授权访问
这两个名词用来区分程序执行的两种不同的状态，他们使用不同的地址空间，用户空间可以通过系统调用和硬件中断来访问内核空间
2.4 内核的编译及加载
2.4.1 Linux内核配置系统组成

Makefile：分布于内核源代码
配置文件（Kconfig）：给用户提供配置选项
配置工具：命令解析器和配置用户界面，都是脚本语言
通过make config、make menuconfig生成.config文件记录哪部分被编入内核，哪部分被编译成模块
source可以引入每一层的Kconfig
2.4.2 Kconfig和Makefile

2.4.2.1linux增加程序需要完成以下3项工作

将编写的源码复制到Linux内核源代码相应得目录中
在目录的Kconfig文件中增加关于源代码相应的编译配置选项
在目录的Makefile文件中增加对新源代码的编译条目
2.4.1.2Makefile语法规则

目标定义：用来定义哪些内容要作为模块编译，哪些要编译并链接进内核，如：obj-y/m/n += foo.o，obj-$(CONFIG_ISDN) += isdn.o
多文件模块的定义：如下，模块名为ext2，有balloc.o、dir.o等目标文件最终链接生成ext2.o直至ext2.ko文件，是否包含xattr.o、acl.o等文件取决于内核配置文件的配置情况。
obj-$(CONFIG_EXT2_FS) += ext2.o
ext2-y :=balloc.o dir.o file.o ...
ext2-$(CONFIG_EXT2_FS_XATTR) += xattr.o xattr_user.o ...
ext2-$(CONGIF_EXT2_FS_XIP) += xip.o
目标层次迭代：如下， 当CONFIG_EXT2_FS的值为y或者m时，kbuild将会把ext2目录列入向下的目录中
obj-$(CONFIG_EXT2_FS) += ext2/
2.4.2.3Kconfig语法规则

配置选项

大多数内核配置选项对应的Kconfig中的一个配置选项，”config” 关键字定义新的配置选项，之后的几行代码定义了诶配置选项的属性。配置选项的属性包含：类型，数据提示，依赖关系，选择关系以及帮助信息、默认值等

config MODVERSIONS
    bool "Module versioning support"
    help
        Usually, you have to use modules compiled with your kernel.
        Saying Y here makes it ...
每个配置选择必须包含指定的类型，包括bool，tristate, string, hex 和int，其中tristate和string是基本的类型，其他类型都是基于这两种类型，类型定以后可以紧跟输入提示，下面两段脚本是等价的
bool "Networking support"
和
bool
prompt "Networking support"
输入提示的一般格式为以下形式，其中可选的if用来表示该提示的依赖关系。
prompt <prompt> [if <expr>]
默认值的格式为以下形式，如果用户不设置对应的选项则配置选项的值就是默认值

default <expr> [if <expr>]
依赖关系的格式为以下形式，多重依赖中间要用“&&”间隔
depends on (或者requires) <expr>
依赖关系也可以用在菜单中的其他选项，如下两段脚本是等价的

bool "foo" if BAR
default y if BAR
和
depends on BAR
bool "foo"
default y
选择关系的格式如下，如果A选择了B，那么A选中的情况下自动选中B
select <symbol> [if <expr>]
数据范围格式如下
range <symbol> <symbol> [if <expr>]
Kconfig中的expr定义如下
<expr> :: <symbol>
            <symbol> '=' <symbol>
            <symbol> '!' <symbol>
            '(' <expr> ')'
            '!' <expr>
                <expr> '&&' <expr>
                <expr> '||' <expr>
symbol分为两类，一类由菜单入口配置项定义的非常数symbol，另一类是作为expr组成部分常数symbol。比如

config SHDMA_R8A73A4
       def_bool y
       depends on ARCH_R8A73A4 && SH_DMA != n
表达式“depends on ARCH_R8A73A4 && SH_DMA !=n”暗示只有当ARCH_R873A4被选中，而SH_DMA没有选中的时候，才可能出现这个SHDMA_R8A73A4。

为int和hex类型的选项设置可以接受的输入值范围，用户只能输入大于等于第一个symbol，且小于等于第二个symbol的值
帮助信息的格式为
help(或---help---)
    开始
    ...
    结束
菜单结构

配置选项在菜单结构的中的位置可有两种方法决定。 
第一种方法为：

menu "Network device support"
    depends on NET
config NETDEVICES
    ...
所有处于“menu”和“endmenu”中的选项都会成为“Network device support”的子菜单，而且，所有的子菜单（config）选项都会继承父菜单（menu）的依赖关系，比如，“Network device support”对“NET”的依赖会被加载到配置选项NETDEVICES的依赖列表中。 
注意：menu后面跟的“Network device support”项仅仅是一个菜单，没有对应真实的匹配项，也不具备不同的三种状态，这与config的区别。

另一种方法为： 
同过分析依赖关系生成菜单结构。如菜单项在一定程度上依赖与前面的选项，他就能成为该选项的子菜单。如果父选项为“n”，子选项不可见；如果父选项可见，子选项才可见。例如：

config MODULES
    bool "Enable loadable module support"

config MODVERSIONS
    bool "Set version information on all module symbol"
    depends on MODULES

comment "module support disabled"
    depends on !MODULES
MODVERSIONS直接依赖MODULES,只有MODULES不为“n”时，该选项才可见。 
除此之外，Kconfig中还可能使用“choices … endchoice”、”comment”、“if…endif”这样的语法结构。其中“choices … endchoice”的结构

choice
<choice options>
<choice block>
endchoice
它定义一个选择群，其接受的选项（choice potions）可以是前面描述的任何属性，例如，LDD6410的VGA输出分辨率可以是1024*768或者是800*600，在driver/video/samsung/Kconfig中就定了如下choice

choice
depends on FB_S3C_VGA
prompt "Select VGA Resolution for S3C Framebuffer"
default FB_S3C_VGA_1024_768
config FB_S3C_VGA_1024_768
    bool "1024*768@60Hz"
    ---help---
    TBA
config FB_S3C_VGA_640_480
    bool "640*480@60Hz"
    ---help---
    TAB
endchoice
上述例子中，prompt配合choice起到提示的作用。 
具体例子见《Linux设备驱动开发详解》第三版 P72-73

2.4.3 Linux内核的引导

上电 => SOC嵌入bootrom 引导=> CPU0上的bootloader
其他非CPU0进入WFI状态等待CPU0唤醒
CPU0引导bootloader唤醒非CPU0，唤醒后和CPU0都投入运行
CPU0导致用户空间的init程序被调用，init派生出其他进程，其他进程在派生出其他进程
bootloader代表为uboot，其代码仓库：http://git.devx.de/u-boot.git/
zimage：是由未压缩的解压算法和压缩的内核组成，bootloader负责解压

《Linux4.0设备驱动开发详解》笔记--第三章：Linux下的C编程特点

3.1 Linux编码风格
参考文章：Documentation/CodingStyle
缩进用TAB
{}使用： 
对于结构体、if、for、while以及switch语句，“{”不另起一行
如果if、for循环后只有1行，不要加“{”和“}”
if和else混合用的时候，else语句不另起一行
对于函数，“{”另起一行
switch和case对齐
3.2 GNU C与ANSI C
零长度和变量长度数组
struct var_data {
    int len;
    char data[0]
};

int main(int argc, char *argv[])
{
    int i, n = argc;
    double x[n];

    for(i=0; i<n; i++)
        x[i] = i;

    return 0;
}
case范围：支持case x … y这样的语法，区间[x,y]中的数都会满足这个case条件
语句表达式：包含在括号里的语句看成一个表达式，它可以出现在任何允许表达式的地方。
typeof关键字：其可以获得x的类型，因此可以借助typedef来定义min这个宏
#define min(x,y) （{
    const typeof(x) _x = (x);  \
    const typeof(y) _y = (y);  \
    (void) (&_x == &_y);       \
    _x < _y ? _x : _y;         \
}）
可变参数宏，标准C就支持可变参数函数，意味着函数的参数是不固定的，如printf()函数，GNU C 中宏也可以接受可变参数目的参数，如
#define pr_debug(fmt,arg...)  \
            printf(fmt,##arg)
这里的arg表示其余的参数，可以是零个或多个，##是为了处理arg不代表任何参数的情况，这时候前面的逗号就显得多余了，使用##之后，CNU C 就会预处理会丢掉前面的逗号，这样

pr_debug("success!\n");
扩展为：
printk("success!\n");
标号元素：允许数组和结构体的元素初始化的顺序任意顺序出现。 
数组初始化方式为在初始化值前添加”[INDEX]=”,或者用”[FIRST … LAST]=”的形式指定一个范围。
unsigned char data[MAX] = {[0 ... MAX] = 0};
结构体初始化方式

struct file_operations ext2_file_operation = {
    .llseek = generic_file_llseek,
    .read = generic_file_read,
    ...
};
当前函数名：FUNCTION或者func保存当前函数的名字
特殊属性声明：GUN C允许申明函数、变量和类型的特殊属性，以便手动优化和定制代码检查的方法，申明方法：在申明后加上attribute((ATTRIBUTE)). ATTRIBUTE为属性说明，若存在多个则逗号隔开。
内建函数：不属于标准库的内建函数通常以__builtin开始
do{} while语句：其主要用于宏定义中，为了保证宏定义的使用者不会出现编译错误，他不对其他使用则做任何假设。
goto语句：一般只限于错误处理中

4.1 内核模块程序结构
加载：insmod，modprobe(同时加载模块的依赖模块)
卸载：rmmod
查看已加载的模块及模块间的依赖关系：lsmod，实际上是分析/proc/modules文件
已加载的模块信息放在/sys/module目录下，没加载一个模块就会在该目录下生成一个以模块名命名的目录，“tree -a”可获取目录树
模块许可声明：申明许可权限，否则将收到内核被污染警告，一般申明为MODULE_LICENSE(“GPL v2”)语句申明采用GPL v2.
模块参数（可选）：模块被加载的时候可以传递给它的值，它本身对对应模块的内部的全局变量
模块导出符（可选）：其他模块可以使用模块导出的函数和变量
模块作者等信息声明
4.2 模块加载函数
Linux内核模块加载函数一般以__init标识申明，如
static int __init initialization_function(void)
{
    /*初始化代码*/
}
module_init(initialization_function);
初始化成功返回0，否则返回错误码。

request_module(const char* fmt, …)：灵活加载内核模块
数据也可以定义为__initdata，只是在初始化的阶段需要的数据，结束后释放占用的内存
4.4 模块卸载函数
一般以__exit标识申明，如

static void __exit cleanup_function(void)
{
    /*释放代码*/
}
module_exit(cleanup_function);
被直接编译进内核的模块的卸载函数会被省略，不编译进内核，因为模块被内置了，也就不会被卸载。

4.5 模块参数
module_param(参数名，参数类型，参数读写权限)：为模块定义一个参数，如下定义一个int参数和char指针参数
static char *book_name = "dissecting Linux Deice Driver";
module_param(book_name, char, S_IRUGO);

static int book_num = 4000;
module_param(book_num, int, S_IRUGO);
“insmod (或modprobe) 模块名 参数名 = 参数值”，不传递则用缺省值，模块被内置时用bootloader通过bootargs里设置“模块名.参数 = 值”给内置模块传递参数。

参数数组：module_param_array(数组名，数组类别，数组长度，参数读写权限)
/sys/module下有已加载模块命名的目录，当“参数读写权限”为0，则此参数不存在sysfs文件系统下对应的节点，否则此模块的目录下会出现parameter目录，其中包含以参数名命令的文件节点，文件权限与设定的权限一致。
允许insmod和modprobe命令时，用逗号隔开输入的数组元素
例：定义两个参数的模块
/*======================================================================
    A kernel module: book
    This example is to introduce module params

    The initial developer of the original code is Baohua Song
    <author@linuxdriver.cn>. All Rights Reserved.
======================================================================*/
#include <linux/init.h>                                
#include <linux/module.h>                                
MODULE_LICENSE("Dual BSD/GPL");                                

static char *book_name = "dissecting Linux Device Driver";              
static int num = 4000;                                

static int book_init(void)                                
{                                
    printk(KERN_INFO " book name:%s\n",book_name);                        
    printk(KERN_INFO " book num:%d\n",num);                               
    return 0;                                
}                                
static void book_exit(void)                                
{                                
    printk(KERN_INFO " Book module exit\n ");                            
}                                
module_init(book_init);                                
module_exit(book_exit);                                
module_param(num, int, S_IRUGO);                                
module_param(book_name, charp, S_IRUGO);

MODULE_AUTHOR("Song Baohua, author@linuxdriver.cn");
MODULE_DESCRIPTION("A simple Module for testing module params");
MODULE_VERSION("V1.0");
通过insmod加参数和不加参数实验，在/var/log/messages文件中查看内核的输出 
在/sys/module/book/parameters目录下输入tree查看参数文件节点

4.6 导出符号
/proc/kallsyms文件记录了符号及符号所在的内存地址
导出符号：EXPORT_SYSBOL(符号名)，EXPORT_SYSBOL_GPL(符号名)（只适用于包含GPL许可权的模块）
例：
/*======================================================================
    A simple kernel module to introduce export symbol

    The initial developer of the original code is Baohua Song
    <author@linuxdriver.cn>. All Rights Reserved.
======================================================================*/
#include <linux/init.h>                                
#include <linux/module.h>                                
MODULE_LICENSE("Dual BSD/GPL");                                

int add_integar(int a,int b)                                
{                                
    return a+b;                             
} 

int sub_integar(int a,int b)                                
{                                
    return a-b;                             
}                            

EXPORT_SYMBOL(add_integar);
EXPORT_SYMBOL(sub_integar);
4.7 模块申明与描述
MODULE_AUTHOR(author);
MODULE_DESCRIPTION(description);
MODULE_VERSION(version_string);
MODULE_DEVICE_TABLE(table_info);
MODULE_ALIAS(alternate_name);
对于USB, PCI等设备驱动，通常创建一个MODULE_DEVICE_TABLE来表明驱动模块支持的设备
4.8 模块的使用计数
try_module_get(&module)和module_put(&module)：模块计数管理接口
try_module_get(&module)：增加模块使用计数，返回0，调用失败，希望使用的的模块不存在或正在被卸载
module_put(&module)：减少模块使用计数
模块的使用计数一般不由模块本身管理，由内核更底层的代码（总线驱动或者此类设备共用的核心模块）来实现，以简化驱动开发
当设备正在使用的时候，模块不可以被卸载
4.9 模块编译
Makefile
模块包含多个.c文件，则Makefile写法
obj-m := modulename.o
modulename-objs := file1.o file2.o ...

《Linux4.0设备驱动开发详解》笔记--第五章：Linux文件系统与设备文件

5.1 Linux文件操作
5.1.1 文件操作系统调用

创建
int create(const char *filename, mode_t mode);  
mode是存取权限，它同umask（在文件创建时需要去掉的一些权限）一起共同决定文件的最终权限 
mode：O_…组合 
- 打开

int open(const char *pathname, int flags);
int open(const char *pathname, int flags, mode_t mode);
如果flags使用了O_CREAT标志，则使用第二个函数，指明创建并打开的文件权限 
数字表示权限的含义 
第一位 第二位 第三位 第四位 第五位 
用户ID 组ID 自己的权限 组的权限 其他人的权限 
例如：创建用户可读写执行，组没有权限，其他人可读执行 => 10 705

open("test", O_CREAT, 10 705);
等价于
open("test", O_CREAT, S_IRWXU | S_IROTH | S_IXOTH | S_ISUID);
读写
int read(int fd, const void *buf, size_t length);
int write(int fd, const void *buf, size_t length);
定位
int lseek(int fd, offset_t offset, int whence);
SEEK_SET：相对于文件开头 
SEEK_CUR：相对于当前指针 
SEEK_END：相对于文件末尾 
offset：可为负数 
lseek(fd, 0, SEEK_END);表示文件的长度

关闭
int close(int fd);
5.1.2 库函数操作

创建和打开
FILE *fopen(const char *path, const char *mode);
mode : r w b 组合 
linux不区分文本文件和二进制文件

读写
int fgetc(FILE *stream);
int fputc(int c, FILE *stream);
char *fgets(char *s, int n, FILE *stream);
int fputs(const char *s, FILE *stream);
int fprintf(FILE *stream, const char *format,...);
int fscanf(FILE *stream, const char *format,...);
size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
size_t fwrite(void *ptr, size_t size, size_t n, FILE *stream);
关闭
int fclose(FILE *stream);
5.2 Linux文件系统
5.2.1 Linux文件系统目录结构

/bin：包含基本命令，如ls、cp等
/sbin：系统命令，如modprobe、ifconfig等
/dev：设备文件存储目录，应用文件通过对这些文件的读写来控制实际设备
/etc：系统配置文件，如账号密码的配置文件，busybox的启动脚本也在这里
/lib：系统库文件
/mnt：挂载目录，如cdrom等目录
/proc：系统运行时，进程及内核信息（CPU、硬盘分区、内存信息等）存放在这里。/proc目录是为文件系统proc的挂载目录，proc不是真正的文件系统，它存在内存中
/tmp：存放运行程序是产生的临时文件
/usr：系统存放程序的目录，如用户命令、用户库等
/sys：sysfs文件系统的映射目录，Linux设备驱动模型中的总线、驱动和设备都可以在该目录下找到对应的节点。当内核检测到新设备时，会在sysfs文件系统中为该设备生成一项新的记录
5.2.2 Linux文件系统与设备驱动

file：代表一个打开的文件，每个打开的文件在内核中都有一个关联的struct file。
inode：包含文件访问权限、属主、组、大小、生成时间、访问时间、最后修改时间等信息
stat + 文件名 =>查看文件的inode信息
inode成员i_rdev字段包含设备号：前12是主设备号，后20位是此设备号 
unsigned int ininor(struct inode *inode)
unsigned int imajor(struct inode *inode)
cat /proc/devices：查看系统注册的设备 
第一列为主设备号
第二列为此设备号
/dev/目录中包含有设备文件
参考 
http://www.cnblogs.com/itech/archive/2012/05/15/2502284.html
5.3 devfs
Linux2.4内核引进，但现在已经由udev取代
5.4 udev用户空间设备管理
5.4.1 udev与devfs区别

机制与策略 
机制：做某件事的方法，相对固定不变
策略：每个步骤采取的方法，灵活不固定
内核中不应该出现策略
udev是利用设备的加入或者移除的时候内核所发送的热拔插事件来工作 
热拔插时设备的详细信息会由内核通过netlink套接字来发送出uevent事件
udev对冷拔插的处理 
Linux提供sysfs下面1个uevent节点，往该节点下写一个“add”,导致内核重新发送netlink，之后udev就会收到冷拔插的netlink消息了
5.4.2 sysfs系统与Linux设备模型

sysfs是与proc、devfs和devpty同类别的虚拟文件系统，它可以产生包括所有的硬件系统的层级视图
sysfs把连接在系统上的设备和总线组织成一个分级的文件，他们可以由用户空间存取，向用户空间导出内核数据结构以及他们的属性
sysfs的一个目的是展示设备驱动模型中各组件的层次关系，顶层目录包括 
block：所有的设备快
bus：所有的总线类型
dev
devices
class：系统中的设备类型（如网卡设备、声卡设备、输入设备等）
fs
kernel
power
bus_type表示总线，device_driver表示驱动，device表示设备
设备和驱动必须依附于总线 
设备和驱动是独立分开注册的，注册设备的时候不需要其驱动已经注册，反之亦然
设备和驱动各自共享·涌向内核，寻找自己的另一半，总线通过match()函数匹配两者
匹配成功会调用xxx_driver的probe函数（xxx是总线的名字，如PCI、spi、USB等）
总系、设备和驱动最终落实为sysfs中的一个目录，其attribute则落实为目录下的文件 
总线、设备和驱动实际上可以认为是kobject的派生类，kobject可以看作是总线、设备和驱动的抽象类
1个kobject对应着sysfs的一个目录
attribute包好show和store两个函数，其用于attribute对应的sysfs的文件读写
事实上，sysfs的目录源于bus_type、device_driver和device，而目录中的文件则来源于attribute
例如：在driver/base/bus.c文件中找到这样的代码
static BUS_ATTR(driver_prove, ...);
static BUS_ATTR(driver_autoprove, ...);
static BUS_ATTR(uevent, ...);
而在/sys/bus/platform等里面可以找到对应的文件

$ls
devices drivers drivers_autoprove drivers_probe uevent
udev的组成
udev目前和systemd项目合并在一起了
udev在用户空间中执行，动态的建立或删除设备的文件，允许每个人都不用关心主次设备号而提供LBS（Linux标准规范）名字，并且根据需要固定名称
udev的工作过程 
当内核检测到系统中出现了新的设备的时候，内核会通过netlink套接字发送uevent
udev获取内核发送的信息，进行规则的匹配 
匹配的事物包括：SUBSYSTEM、ACTION、attribute、内核提供的名称（通过KETNEL=）以及其他的环境变量
例如：在Linux系统上插入Kingston的U盘，通过udev的工具“udevadm monitor–kernel –property –udev”捕获到uevent包含的信息（包括U盘的设备商、U盘的类型、设备编号等等），根据这些信息创建一个规则，以便在插入的时候，为该U盘创建一个/dev/KingstomUD的符号链接
SUBSYSTEM=="block", ACTION=="add", KERNEL=="*sd", ENV{ID_TYPE}=="disk", ENV{ID_VENDOR}=="Kingston", ENV{ID_USB_DRIVER}=="usb-storage", SYMLINK+="kingstonUD"
插入U盘后就会自动的在/dev/下面创建一个符号链接

5.4.4 udev 规则文件

规则文件一行为单位，以“#”为行代表注释符，其余的每一行代表一个规则
每个规则分成一个或多个匹配部分和赋值部分 
匹配部分和赋值部分用专用的关键字来表示
匹配关键字包括：ACTION/KERNEL/BUS/SUBSYSTEM/ATTR等
赋值关键字包括：NAME/SYMLINK/OWNER/GROUP/IMPORT/MODE等
例如
SUBSYSTEM=="net", ACTION=="add", KERNEL=="?*", ATTR{address}=="08:00:27:35:be:ff", ATTR{dev_id}=="0x0", ATTR{type}=="1", KERNEL=="eth*", NAME="ETH1"
 - 规则意思：当系统中出现新的硬件属于net子系统范畴，系统柜该硬件采取的动作是“add”这个硬件，且这个硬件的address属性信息等于“08:00:27:35:be:ff”，dev_id属性等于“0x0”,"type"属性是1等，这个硬件在udev层次实行的动作是创建/dev/eth1.
udev 规则可以使用通配符，如*，？，[a-z]等，此外，%k就是KERNEL，%n就是KERNEL的序号(如存储设备的分区号)
Android采用的和udev类似的void机制

《Linux4.0设备驱动开发详解》笔记--第六章：Linux字符设备驱动

6.1 linux字符设备驱动结构
6.1.1 cdev结构体

cdev结构体描述一个字符设备
struct cdev { 
        struct kobject kobj; //内嵌的kobject对象
        struct module *owner;   //所属模块 
        const struct file_operations *ops;//文件操作结构
        struct list_head list; 
        dev_t dev;          //设备号，int 类型
        unsigned int count; 
}; 
cdev的dev_t成员定义了设备号，高12位为主设备号，低20位为次设备号 
获取主、次设备号: 
MAJOR(dev_t dev)
MINOR(dev_t dev)
主次设备号生成dev_t：MKDEV(int major,int minor)
cdev结构体相关的操作函数
void cdev_init(struct cdev *, const struct file_operations *);//建立cdev和file_operation之间的连接
struct cdev *cdev_alloc(void); //动态申请一个cdev内存 
void cdev_put(struct cdev *p);   //释放 
int cdev_add(struct cdev *, dev_t, unsigned);  //注册设备
void cdev_del(struct cdev *);//注销设备
6.1.2 分配和释放设备号

在注册设备之前应该先申请设备号 
register_chrdev_region()用于已知设备号
register_chrdev_region()用于动态申请
int register_chrdev_region(dev_t from,unsigned count,const char *name)

int alloc_chrdev_region(dev_t *dev,unsigned baseminor,unsigned count,const char *name)
释放设备号
void unregister_chrdev_region(dev_t from,unsigned count)
注册与注销字符设备顺序关系如下：
register_chrdev_region()－－>cdev_add()     //此过程在加载模块中 
cdev_del()-->unregister_chrdev_region()     //此过程在卸载模块中
6.1.3 字符设备驱动组成

字符设备的模块加载与卸载函数
字符设备驱动的file_operation结构体中的成员函数，大多数实现以下函数 
read()
write()
ioctl()
copy_from_user()：用户空间缓冲区到内核空间
copy_to_user()：内核空间到用户空间缓冲区 
返回0：成功
返回正数：不能被复制的字节数
负数：操作失败
复制的内容是简单的类型，如int、char、long等，则可以用以下函数 
put_user、get_user
上述函数中_user是一个宏，表示其后的指针指向用户空间
内核空间访问用户空间缓存时需要合法性检查 
access_ok(type, add, size)：确认缓存区确实属于用户空间
ioctl函数 
设备类型字段为一个幻数，可以使0-0xff的值，内核中的ioctl-number.txt有推荐的已经存在的幻数，新设备区应该避免与其冲突
方向字段表示数据传输的方向 
_IOC_NONE：无数据传输
_IOC_READ：读
_IOC_WRITE：写
_IOC_READ|_IOC_WRITE：双向
设备类型	序列号	方向	数据尺寸
8位	8位	2位	13/14位
预定义命令：内核中预定了一些I/O控制命令，如果某设备中抱哈没了与预定义命令一样的命令码，则这些命令会作为预定义命令被内核处理而不是被设备驱动处理

FIOCLEX：通知内核当exec()系统调用发生时，自动关闭打开的文件
FIONCLEX：与FIOCLEX相反，清除由FIOCLEX命令设置的标志
FIOQSIZE：获得一个文件和目录的大小，当用于设备文件时返回一个ENOTTY错误
FIONBIO：修改在filp->f_flags中的O_NONBLOCK标志

《Linux4.0设备驱动开发详解》笔记--第七章：Linux设备中的并发控制

7.1 并发与竞态
并发是指多个执行单元同时、并发的被执行，而并发的执行单元对共享资源（硬件资源、软件上的的全局变量、静态变量等）的访问则很容易导致竟态
竟态发生在以下几种情况 
对称多处理器（SMP）的多个CPU
单CPU内进程与抢占它的进程
中断与进程
解决方法是保证对共享资源的互斥访问 
访问共享资源的代码区域称为临界区，临界区需要以某种互斥机制保护 
互斥途径：中断屏蔽、原子操作、信号量、自旋锁、互斥体等
7.2 编译乱序和执行乱序
编译乱序是编译器的问题，而执行乱序是处理器运行时的行为
编译屏障：在代码中设置barrier()屏障来阻挡编译器优化
内存屏障指令：解决多核间一个核的内存行为对另一个核可见的问题 
arm处理器的内存屏障指令有 
DMB：数据内存屏障
DSB：数据同步屏障
LSB：指令同步屏障
linux的自旋锁、互斥量的等互斥逻辑需要用到上述指令
7.3 中断屏蔽
中断屏蔽的使用方法 
local_irp_disable()与local_irp_enable()只能禁止或是能本CPU内的中断
local_irp_save(flags)与local_irp_restore(flags)：处理屏蔽或使能中断还能保存目前CPU的中断信息，对arm就是保存和恢复cpsr
local_bh_disable()和loacal_bh_diable()：禁止和使能中断的底半部
local_irp_disable();
...
critical section /*临界区*/
...
local_irp_enable();
7.4 原子操作
原子操作可以保证对一个整型数据的修改是排他性的
原子操作函数分为对整型和位的原子操作
7.4.1 对整型的原子操作

设置原子变量的值
//设置原子变量的值为i
void atomic_set(atomic_t *v, int i);
//定义原子变量v并初始化为0
atomic_t v = ATOMIC_INIT(0);
获取原子变量的值
//返回原子变量的值
atomic_read(atomic_t *v);
原子变量加、减
//原子变量增加1
void atomic_sub(int i, atomic_t *v);
原子变量自增、自减
//原子变量增加1
void atomic_inc(atomic_t *v);
//原子变量减少1
void atomic_dec(atomic_t *v);
操作并测试，下属操作对原子变量执行自增、自检和减操作后（没有加操作）。测试其是否为0，位0返回true，否则返回false
int atomic_inc_and_test(atomic_t *v);
int atomic_dec_and_test(atomic_t *v);
int atomic_sub_and_test(int i, atomic_t *v);
操作并返回，丅述操作是对原子变量的加、减和自增、自减操作，并返回新的值
int atomic_add_return(int i, atomic_t *v);
int atomic_sub_return(int i, atomic_t *v);
int atomic_intc_return(atomic_t *v);
int atomic_dec_return(atomic_t *v);
7.4.2 位原子操作

设置位，丅述设置addr地址的底nr位
void set_bit(nr,void *addr);
清除位
void change_bit(nr, void *addr);
改变位，下述代码对addr的nr位进行反置
void change_bit(nr, void *addr);
测试位，返回addr的第nr位
test_bit(nr, void *addr)
测试并操作位
int test_and_se_bit(nr, void *addr);
int test_and_clear_bit(nr, void *addr);
int test_and_change_bit(nr, void *addr);
例如：使用原子变量使得文字只能被一个进程打开
static atomic_t xxx_available = ATOMIC_INIT(1);

static int xxx_open(struct inode *inode, struct file *filp)
{
    ...
    if(!atomic_dev_and_test(&xxx_available)){
        atomic_inc(&xxx_available);
        return -EBUSY;//已打开
    }
    ...
    return 0;//成功
}

static int xxx_release(struct inode* inode, struct file *filp){
        atomic_inc(&xxx_available);//释放设备
        return 0;
    }
7.5 自旋锁
7.5.1 自旋锁的使用

自旋锁是一种典型的对临界资源进行互斥访问的手段，其名称来源于他的工作方式
为了获取自旋锁，在某CPU上的运行需要先执行一个原子操作，该操作测试并设置某个内存变量。 
如果测试结果表明锁已经空闲，则程序成功获取自旋锁并继续执行
如果测试结果表明锁仍在被使用，则程序将在一个小的循环内重复这个“测试并设置”操作，即所谓的自旋
linux系统中对自旋锁的相关操作 
定义自旋锁：spinlock_t lock;
初始化自旋锁：spin_lock_init(lock);
获得自旋锁：spin_lock(lock);或者spin_locktry(lock);
释放自旋锁：spin_unlock(lock);
自旋锁主要针对SMP或者单CPU单内核可抢占的情况
对于单CPU但是内核不支持抢占的情况，自旋锁自动转化为空操作 
单CPU系统和可抢占的系统中，自旋锁持有期间中内核的抢占将被禁止
多核SMP的情况下，任何一个核拿到了自旋锁，该核上的抢占调度也暂时禁止，但是没有禁止另外一个核的抢占调度
自旋锁的临界区可以被中断或者底半部影响，因而需要自旋锁和其他操作的配合 
spin_lock_irp() = spin_lock() + local_irq_disable()
spin_unlock_irp = spin_unlock() +local_irq_enable();
spin_lock_irqsave() = spin_lock() + local_irq_save();
spin_unlock_irqrestore() = spin_unlock() + local_irq_restore()
spin_lock_bh() = spin_lock() + local_bh_disable()
spin_unlock_bh() = spin_unlock() + local_bh_enable()
使用自旋锁应该谨慎，同时需要注意几个问题 
自旋锁是忙等待，在自旋的时候CPU不做其他的操作，因此只有在占用锁很短的情况下才使用自旋锁
可能因为递归的使用而使系统死锁
在自旋期间，不能调用调用可能引起进程调度的函数，可能导致内核崩溃
在单核情况下，也该认为自己的CPU是多核的，以突出驱动的跨平台性
7.5.2 读写自旋锁

自旋锁不关心临界区在进行什么操作，一视同仁
自旋锁的衍生锁读写自旋锁允许读的并发，它保留了自选的概念，在写方面只能有一个进程，读方面可以有多个执行单元，但是读和写不能同时进行
定义并初始化读写自旋锁:
rwlock_t my_rwlock1 = RW_LOCK_UNLOCKED; //静态初始化
rwlock_t my_rwlock2;
rwlock_init(&my_rwlock2); //动态初始化
读锁定:
void read_lock(rwlock_t* lock);
void read_lock_irqsave(rwlock_t* lock, unsigned long flags);
void read_lock_irq(rwlock_t* lock);
void read_lock_bh(rwlock_t* lock);
读解锁:
void read_unlock(rwlock_t* lock);
void read_unlock_irqrestore(rwlock_t* lock, unsigned long flags);
void read_unlock_irq(rwlock_t* lock);
void read_unlock_bh(rwlock_t* lock);
在对共享资源进行读取之前,应该先调用读锁定函数锁定共享资源,完成之后再调用读解锁函数释放共享资源;

写锁定:
void write_lock(rwlock_t* lock);
void write_lock_irqsave(rwlock_t* lock, unsigned long flags);
void write_lock_irq(rwlock_t* lock);
void write_lock_bh(rwlock_t* lock);
void write_trylock(rwlock_t* lock);
写解锁:
void write_unlock(rwlock_t* lock);
void write_unlock_irqrestore(rwlock_t* lock);
void write_unlock_irq(rwlock_t* lock);
void write_unlock_bh(rwlock_t* lock);
 - 在对共享资源进行写操作之前,应该先调用写锁定函数锁定共享资源,完成之后再调用写解锁函数释放共享资源;与spin_trylock()一样,write_trylock()也只是尝试获得写自旋锁,不管是否成功,都会立即返回;
读写自旋锁使用套路:
rwlock_t lock;      //定义读写自旋锁
rwlock_init(&lock); //初始化读写自旋锁

read_lock(&lock);   //读时加锁
......
//临界区操作
......
read_unlock(&lock); //读后解锁;

write_lock_irqsave(&lock, flags);    //写时加锁
......
//临界区操作
......
write_lock_irqrestore(&lock, flags); //写后解锁;
7.5.3 顺序锁
顺序锁相关操作：
void write_seqlock(seqlock_t *s1);
void write_sequnlock(seqlock_t *s1);

//宏调用，相当于：write_seqlock()+local_irq_save()
write_seqlock_irqsave(lock,flags)
write_sequnlock_irqrestore(lock,flags)

//宏调用，相当于：write_seqlock()+local_irq+disable()
write_seqlock_irq(lock)
write_sequnlock_irq(lock)

//宏调用，相当于：write_seqlock()+local_bh_disable()
write_seqlock_bh(lock)
write_sequnlock_bh(lock)

int write_tryseqlock(seqlock_t *s1)，此函数和上面提到的类似。
写执行单元使用如下一种模式的顺序锁：
write_seqlock(&seqlock);
.........//写操作代码块
write_sequnlock(&seqlock);
读执行单元涉及如下顺序锁操作：
读开始：unsigned read_seqbegin(const seqlock_t *s1);
//读执行单元在访问共享资源时要，调用该函数，返回锁s1的顺序号
read_seqbegin_irqsave(lock,flags)  
//等同于：local_irq_save()+read_seqbegin()
重读：int read_seqretry(const seqlock_t *s1,unsigned iv) 
//在读结束后调用此函数来检查，是否有写执行单元对资源进行操作，若有，则重新读。iv 为锁的顺序号。
7.5.4 读-复制-更新（RCU）

RCU的读端没有锁、内存屏蔽、原子指令类的开销，机会可以认为是直接读
RCU的写端访问它的共享资源前首先要复制一个副本，然后对副本进行修改，然后使用一个回调机制在适当的时机把指向原来数据的指针重新指向新的修改数据 
这个时机就是所有引用该数据的CPU都退出对共享数据读操作的时候
等待适当时机的这一时期称为宽限期
RCU的有点 
允许多个读执行单元同时访问保护区
允许多个读写执行单元同时访问保护区数据
RCU不能替代读写锁 
因为RCU的写执行单元的同步开销较大，当写较多的时候，对读执行单元的性能提高不能弥补写执行单元同步导致的损失
参考: 
RCU机制
TREE RCU实现之一 —— 数据结构
TREE RCU实现之二 —— 主干函数
TREE RCU实现之三 —— 定期调用 
http://blog.csdn.net/junguo/article/details/8244530/ 
http://blog.csdn.net/junguo/article/details/8258231 
http://blog.csdn.net/junguo/article/details/8258261 
http://blog.csdn.net/junguo/article/details/8268277
7.6 信号量
定义信号量
struct semaphore sem;
初始化：
void sema_init (struct semaphore *sem, int val);
void init_MUTEX (struct semaphore *sem); //将sem的值置为1，表示资源空闲
void init_MUTEX_LOCKED (struct semaphore *sem); //将sem的值置为0，表示资源忙
申请内核信号量所保护的资源：
//可引起睡眠
void down(struct semaphore * sem); 
//down_interruptible能被信号打断
int down_interruptible(struct semaphore * sem);  
// 非阻塞函数，不会睡眠。无法锁定资源则马上返回
int down_trylock(struct semaphore * sem); 
释放内核信号量所保护的资源：
void up(struct semaphore * sem);
7.7 互斥体
互斥体提供了两种机制：经典互斥体和实时互斥体
经典互斥体结构体： （会导致无限制优先级反转问题）
struct mutex {
    /* 1: unlocked, 0: locked, negative: locked, possible waiters */
    atomic_t  count;
    spinlock_t
    wait_lock;
    struct list_head
    wait_list;
    #if defined(CONFIG_DEBUG_MUTEXES) || defined(CONFIG_SMP)
    struct task_struct
    *owner;
    #endif
    #ifdef CONFIG_DEBUG_MUTEXES
    const char 
    *name;
    void  *magic;
    #endif
    #ifdef CONFIG_DEBUG_LOCK_ALLOC
    struct lockdep_map
    dep_map;
    #endif
};
实时互斥体结构体：
struct rt_mutex {
    raw_spinlock_t
    wait_lock;
    struct plist_head
    wait_list;
    struct task_struct
    *owner;
    #ifdef CONFIG_DEBUG_RT_MUTEXES
    int  save_state;
    const char 
    *name, *file;
    int  line;
    void  *magic;
    #endif
};
操作：
struct mutex my_mutex;    
mutex_init(&my_mutex);   
void mutex_lock(struct mutex* lock);                       //获取互斥体,不可被信号中断
void mutex_lock_interruptible(struct mutex* lock);     //获取互斥体,可被信号打断
int mutex_trylock(struct mutex* lock);                     //尝试获取互斥体
void mutex_unlock(struct mutex* lock);                     //释放互斥体

int mutex_is_locked(struct mutex* lock):
//该函数检查互斥锁lock是否处于锁定状态。返回1,表示已锁定;返回0,表示未锁定;
int mutex_lock_interruptible(struct mutex* lock);  //该函数可被信号打断
int mutex_lock_killable(struct mutex* lock);       //该函数可被kill信号打断
用例：
struct mutex my_mutex;   
mutex_init(&my_mutex);   

mutex_lock(&my_mutex);  
...临界区...                 
mutex_unlock(&my_mutex); 
7.8 完成量
完成量：表示一个执行单元需要等待另一个执行单元完成某事后方可执行。 
它是一种轻量级机制，为了完成进程间的同步而设计
使用完成量等待时，调用进程是以独占睡眠方式进行等待的
不是忙等待
结构体 
done变量是完成量要保护的对象
wait则是申请完成量的进程等待队列
struct completion {
    unsigned int done;
    wait_queue_head_t wait;
};
初始化函数 
done变量被初始化为0.
内核代码中wait_for_common函数其实就是对done变量作判断，若done变量没有大于0，则它一直处于while循环中。
complete函数就是对done变量加1。wait_for_common函数便会退出while循环，同时将done减1，表示申请完成量成功。
static inline void init_completion(struct completion *x)
{
x->done = 0;
init_waitqueue_head(&x->wait);
}
操作：
struct completion my_completion;    //定义完成量my_completion

init_completion(&my_completion);    //初始化完成量my_completion

void wait_for_completion(struct completion* comp)
//该函数等待一个完成量被唤醒。该函数会阻塞调用进程,如果所等待的完成量没有被唤醒,那就一直阻塞下去,而且不会被信号打断;

int wait_for_completion_interruptible(struct completion* comp)
//该函数等待一个完成量被唤醒。但是它可以被外部信号打断;

int wait_for_completion_killable(struct completion* comp)
//该函数等待一个完成量被唤醒。但是它可以被kill信号打断;

unsigned long wait_for_completion_timeout(struct completion* comp, unsigned long timeout)
//该函数等待一个完成量被唤醒。该函数会阻塞调用进程,如果所等待的完成量没有被唤醒,调用进程也不会一直阻塞下去,而是等待一个指定的超时时间timeout,当超时时间到达时,如果所等待的完成量仍然没有被唤醒,那就返回;超时时间timeout以系统的时钟滴答次数jiffies计算

bool try_wait_for_completion(struct completion* comp)
//该函数尝试等待一个完成量被唤醒。不管所等待的完成量是否被唤醒,该函数都会立即返回

bool completion_done(struct completion* comp)
//该函数用于检查是否有执行单元阻塞在完成量comp上(是否已经完成),返回0,表示有执行单元被完成量comp阻塞;相当于wait_for_completion_timeout()中的timeout=0

void complete(struct completion* comp)
//该函数只唤醒一个正在等待完成量comp的执行单元

void complete_all(struct completion* comp)
//该函数唤醒所有正在等待同一个完成量comp的执行单元

NORET_TYPE void complete_and_exit(struct completion* comp, long code)
//该函数唤醒一个正在等待完成量comp的执行单元,并退出,code为退出码
注意:在内核处理完请求之后,必须调用这三个函数中的一个,来唤醒其它正在等待的进程

《Linux4.0设备驱动开发详解》笔记--第八章：linux设备驱动的阻塞与非阻塞

8.1 阻塞与非阻塞I/O
阻塞操作 ： 是指在执行设备操作时，若不能获得资源，则挂起进程直到满足操作条件后再进行操作。

被挂起的进程进入休眠， 被从调度器移走，直到条件满足。
非阻塞操作：在不能进行设备操作时，并不挂起，它或者放弃，或者不停地查询，直到可以进行操作。

非阻塞应用程序通常使用select系统调用查询是否可以对设备进行无阻塞的访问最终会引发设备驱动中poll函数执行。
阻塞与非阻塞例程：
//阻塞例程
char buf;
fd = open("/dev/ttyS1",O_RDWR);
.....
res = read(fd,&buf,1); //当串口上有输入时才返回,没有输入则进程挂起睡眠
if(res == 1)
{
    printf("%c/n",buf);
}
//非阻塞例程
char buf;
fd = open("/dev/ttyS1",O_RDWR|O_NONBLOCK);//O_NONBLOCK 非阻塞标识
.....
while(read(fd,&buf,1)!=1);//串口上没有输入则返回，所以循环读取
printf("%c/n",buf);
8.1.1 等待队列

定义“等待队列头”
wait_queue_head_t my_queue;
初始化“等待队列头”
init_wait_queue_head(&my_queue);
定义并初始化等待队列头的快捷方式(宏)
DECLARE_WAIT_QUEUE_HEAD(name)
定义等待队列 
DECLARE_WAITQUEUE()：该宏用于定义并初始化一个名为name的等待队列
**DECLARE_WAITQUEUE(name, tsk)** 
添加/移除等待队列 
add_wait_queue()：将等待队列wait添加到等待队列头q指向的等待队列链表中
remove_wait_queue()：将等待队列wait从附属的等待队列头q指向的等待队列链表中移除
void fastcall add_wait_queue(wait_queue_head_t *q, wait_queue_t *wait); 

void fastcall remove_wait_queue(wait_queue_head_t *q, wait_queue_t *wait); 
等待事件 
wait_event(queue, condition)：queue作为等待队列头的等待队列被唤醒，而且condition必须满足，否则阻塞。不能被信号打断
wait_event_interruptible()：可以被信号打断
wait_event_timeout()：加上_timeout后意味着阻塞等待的超时时间，以jiffy为单位。在timeout到达时不论condition是否满足，均返回
wait_event(queue, condition);
wait_event_interruptible(queue, condition) ;
wait_event_timeout(queue, condition) ;
wait_event_interruptible_timeout(queue, condition)
唤醒队列 
唤醒以queue作为等待队列头的所有等待队列中所有属于该等待队列头的等待队列对应的进程
wake_up()应与wait_event()或wait_event_timeout()成对使用
wake_up()可唤醒处于TASK_INTERRUPTIBLE和TASK_UNINTERRUPTIBLE的进程
wake_up_intterruptible()则应与wait_event_interruptible()或wait_envent_interruptible_timeout()成对使用
wake_up_interruptible()只能唤醒处于TASK_INTERRUPTIBLE的进程
void wake_up(wait_queue_head_t *queue);
void wake_up_interruptible(wait_queue_head_t *queue);
在等待队列上睡眠 
sleep_on()：将目前进程的状态设置成TASK_UNINTERRUPTIBLE，并定义一个等待队列，之后把它附属到等待队列头q，直到资源可获得，q引导的等待队列被唤醒。
interruptible_seep_on()：将目前进程的状态设置成TASK_INTERRUPTIBLE，并定义一个等待队列，之后把它附属到等待队列头q，直到资源可获得，q引导的等待队列被唤醒或者进程收到信号。
sleep_on(wait_queue_head_t *q); 
interruptible_seep_on(wait_queue_head_t *q); 
例程：设备驱动中使用等待队列
static ssize_t xxx_write(struct file *file, const char *buffer, size_t count, loff_t *ppos)
{
    ...
    DECLARE_WAITQUEUE(wait, current);
    add_wait_queue(&xxx_wait, &wait);
    /*等待设备缓冲区可写*/
    do {
        avail = device_writable(...);
        if(avail < 0) {
            if(file->f_flags & O_NONBLOCK) {
                ret = -EAGAIN;
                goto out;
            }
            __set_current_state)(TASK_INTERRUPTIBLE);
            schedule();
            if(signal_pending(current)){
                ret = -ERESTARTSYS;
                goto out;
            }
        } 
    } while(avail < 0);
    /*写设备缓存区*/
    device_write(...)
    out:
    remove_wait_queue(&xxx_wait, &wait);
    set_current_state(TASK_RUNNING);
    return ret;
}
8.2 轮询操作
8.2.1 轮询的概念与作用

非阻塞I/O的应用程序通常使用select()和poll()系统调用查询是否可对设备进行无阻塞的访问。
select()和poll()系统调最终会引发设备中的poll()函数执行(xxx_poll()).
8.2.2 应用程序中的轮询编程

select()系统调用： 
readfds、writefds、exceptfds分别是被select()监视的读、写和异常处理的文件描述符集合
numfds的值是需要检查的号码最高的文件描述符加1
timeout参数是一个指向struct timeval类型的指针，它可以使select()在等待timeout时间后若没有文件描述符准备好则返回
int select(int numfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
timeout参数是一个指向struct timeval类型的指针，它可以使select()在等待timeout时间后若仍然没有文件描述符准备好则超时返回
struct timeval
{
int tv_sec; // 秒
int tv_usec; // 微秒
}
设置、清除、判断文件描述符集合：
FD_ZERO(fd_set *set) // 清除一个文件描述符集
FD_SET(int fd, fd_set *set) // 将一个文件描述符加入文件描述符集中
FD_CLR(int fd, fd_set *set) // 将一个文件描述符从文件描述符集中清除
FD_ISSET(int fd, fd_set *set) // 判断文件描述符是否被置位
例程：驱动函数中的poll()函数典型模板
#inlcude------
main()
{
    int fd,num;
    char rd_ch[BUFFER_LEN];
    fd_set rfds,wfds; //读写文件描述符集
    //以非阻塞方式打开/dev/globalfifo设备文件
    fd=open("/dev/globalfifo",O_RDWR|O_NONBLOCK);
    if(fd != -1)
    {
        //FIFO 清零
        if(ioctl(fd,FIFO_CLEAR,0) < 0)
        {
            printf("ioctl cmd failed /n");
        }
        while(1)
        {
            FD_ZERO(&rfds);
            FD_ZERO(&wfds);
            FD_SET(fd,&rfds);
            FD_SET(fd,&wfds);
            select(fd+1,&rfds,&wfds,null,null);
        }
    }
}
8.2.3 设备驱动中的轮询编程

poll()函数： 
参数 
file：file结构指针
poll_table：轮训表指针
作用 
对可能引起设备文件状态变化的等待队列调用poll_wait()函数，将对应的等待队列头添加到poll_table
返回表示是否能对设备进行无阻塞读、写访问的掩码
返回 
poll()函数应该返回设备资源的可获取状态，即POLLIN、POLLOUT、POLLPRI、POLLERR、POLLNVAL等宏的位“或”结果。
unsigned int (*poll)(struct file *flip, struct poll_table *wait);
poll_wait()函数 
用于向poll_table注册等待队列，该函数不会引起阻塞
工作是把当前进程添加到wait参数指定的等待列表(poll_table)中
void poll_wait(struct file *flip, wait_queue_head_t *queue, poll_table *wait);
用户空间调用select()和poll()接口，设备驱动提供poll()函数 
设备驱动的poll()本身不会阻塞
poll()和select()系统调用则会阻塞地等待文件描述符集合中的至少一个可访问或超时。
poll()模板：
static unsigned int xxx_poll(struct file *filp, poll_table *wait)
{
    unsigned int mask = 0;
    struct xxx_dev *dev = filp->private_data; // 获得设备结构指针
    ...
    poll_wait(filp, &dev->r_wait, wait); // 加读等待队列头
    poll_wait(filp, &dev->w_wait, wait); // 加写等待队列头
    if(...) // 可读
    {
        mask |= POLLIN | POLLRDNORM; // 标示数据可获得
    }
    if(...) // 可写
    {
        mask |= POLLOUT | POLLWRNORM; // 标示数据可写入
    }
    ...
    return mask;
}
支持轮询操作的globalfifo驱动
static unsigned int gloablfif0_poll(struct file *filp,poll_table *wait)
{
    unsigned int mask = 0;
    struct globalfifo_dev *dev = filp->private_data;

    down(&dev->sem);

    poll_wait(filp,&dev->r_wait , wait) ;
    poll_wait(filp,&dev->r_wait , wait) ;

    if(dev->current_len != 0)
    {
        mask |= POLLIN | POLLRDNORM; 
    }

    if(dev->current_len != GLOBALFIFO_SIZE)
    {
        mask |= POLLOUT | POLLWRNORM;
    }

    up(&dev->sem);
    return mask;
}

《Linux4.0设备驱动开发详解》笔记--第九章：Linux设备驱动中的异步通知与同步I/O

在设备驱动中使用异步通知可以使得对设备的访问可进行时，由驱动主动通知应用程序进行访问。因此，使用无阻塞I/O的应用程序无需轮询设备是否可访问，而阻塞访问也可以被类似“中断”的异步通知所取代。异步通知类似于硬件上的“中断”概念，比较准确的称谓是“信号驱动的异步I/O”。

9.1 异步通知的概念和作用
异步通知：一旦设备就绪，则主动通知应用程序，该应用程序无需查询设备状态
几种通知方式比较： 
阻塞I/O ：一直等待设备可访问后开始访问
非阻塞I/O：使用poll()查询设备是否访问
异步通知 ：设备主动通知用户应用程序
-
9.2 linux异步通知编程

9.2.1 linux信号

作用：linux系统中，异步通知使用信号来实现
SIGHUP     终止进程     终端线路挂断
SIGINT     终止进程     中断进程
SIGQUIT   建立CORE文件终止进程，并且生成core文件
SIGILL   建立CORE文件       非法指令
SIGTRAP   建立CORE文件       跟踪自陷
SIGBUS   建立CORE文件       总线错误
SIGSEGV   建立CORE文件       段非法错误
SIGFPE   建立CORE文件       浮点异常
SIGIOT   建立CORE文件       执行I/O自陷
SIGKILL   终止进程     杀死进程
SIGPIPE   终止进程     向一个没有读进程的管道写数据
SIGALARM   终止进程     计时器到时
SIGTERM   终止进程     软件终止信号
SIGSTOP   停止进程     非终端来的停止信号
SIGTSTP   停止进程     终端来的停止信号
SIGCONT   忽略信号     继续执行一个停止的进程
SIGURG   忽略信号     I/O紧急信号
SIGIO     忽略信号     描述符上可以进行I/O
SIGCHLD   忽略信号     当子进程停止或退出时通知父进程
SIGTTOU   停止进程     后台进程写终端
SIGTTIN   停止进程     后台进程读终端
SIGXGPU   终止进程     CPU时限超时
SIGXFSZ   终止进程     文件长度过长
SIGWINCH   忽略信号     窗口大小发生变化
SIGPROF   终止进程     统计分布图用计时器到时
SIGUSR1   终止进程     用户定义信号1
SIGUSR2   终止进程     用户定义信号2
SIGVTALRM 终止进程     虚拟计时器到时
9.2.2 信号的接收

信号捕获函数signal() 
参数： 
signum：信号值
handler：针对signum的处理函数 
若为SIG_IGN：忽略该信号
若为SIG_DFL：系统默认方式处理
若为用户自定义函数：信号被捕获，该函数被执行
返回值 
成功：最后一次为信号signum绑定的处理函数的handler值
失败：返回SIG_ERR
sigaction() 
作用：改变进程接收到特定信号后的行为
参数 
signum：信号值 
除SIG_KILL及SIG_STOP以外的一个特定有效的信号
act：指向结构体sigaction的一个实例的指针 
在结构体sigaction中，指定了处理信号的函数，若为空则进程会以缺省值的方式处理信号
oldact：保存原来对应的信号的处理函数，可设为NULL
int sigaction(int signo,const struct sigaction *restrict act, struct sigaction *restrict oact);
实例：使用信号实现异步通知 
在用户空间处理设备释放信号的准备工作 
通过F_SETOWN IO控制命令设置设备文件的拥有者为本进程，以使信号被本进程捕获
通过F_SETFL IO控制命令设置设备文件以支持FASYNC，及异步通知模式
通过signal()函数连接信号和信号处理函数
//启动信号机制

void sigterm_handler(int sigo)
{

char data[MAX_LEN];
int len;
len = read(STDIN_FILENO,&data,MAX_LEN);
data[len] = 0;
printf("Input available:%s\n",data);
exit(0);

}

int main(void)
{

int oflags;
//启动信号驱动机制

signal(SIGIO,sigterm_handler);
fcntl(STDIN_FILENO,F_SETOWN,getpid());
oflags = fcntl(STDIN_FILENO,F_GETFL);
fctcl(STDIN_FILENO,F_SETFL,oflags | FASYNC);
//建立一个死循环，防止程序结束

whlie(1);

return 0;

}
9.2.3 信号的释放 (在设备驱动端释放信号)

为了是设备支持异步通知机制，驱动程序中涉及以下3项工作 
支持F_SETOWN命令，能在这个控制命令处理中设置filp->f_owner为对应的进程ID。不过此项工作已由内核完成，设备驱动无须处理
支持F_SETFL命令处理，每当FASYNC标志改变时，驱动函数中的fasync()函数得以执行。因此，驱动中应该实现fasync()函数
在设备资源中可获得，调用kill_fasync（）函数激发相应的信号
-
设备驱动中异步通知编程： 
处理FASYNC标志变更函数：fasync_helper()
释放信号的函数：kill_fasync()
int fasync_helper(int fd,struct file *filp,int mode,struct fasync_struct **fa);

 void kill_fasync(struct fasync_struct **fa,int sig,int band);
将fasync_struct结构体指针放到设备结构体中是最佳的选择
//异步通知的设备结构体模板
struct xxx_dev{
    struct cdev cdev;
    ...
    struct fasync_struct *async_queue;//异步结构体指针
};
在设备驱动中的fasync()函数中，只需简单地将该函数的3个参数以及fasync_struct结构体指针的指针作为第四个参数传入fasync_helper()函数就可以了，模板如下
static int xxx_fasync(int fd,struct file *filp, int mode)
{
　　struct xxx_dev *dev = filp->private_data;
　　return fasync_helper(fd, filp, mode, &dev->async_queue);
}
在设备资源可获得时应该调用kill_fasync()函数释放SIGIO信号，可读时第三个参数为POLL_IN，可写时第三个参数为POLL_OUT，模板如下
static ssize_t xxx_write(struct file *filp,const char __user *buf,size_t count,loff_t *ppos)

{
    struct xxx_dev *dev = filp->private_data;
    ...
    //产生异步读信息
    if(dev->async_queue)
    kill_fasync(&dev->async_queue,GIGIO,POLL_IN);
    ...
}
最后在文件关闭时，要将文件从异步通知列表中删除
int xxx_release(struct inode *inode,struct file *filp)

{
    //将文件从异步通知列表中删除
    xxx_fasync(-1,filp,0);
    ...
    return 0;
}
9.4 linux异步I/O
9.4.1 AIO概念与GNU C库 AIO

9.4.1.1 AIO概念

同步I/O：linux系统中最常用的输入输出（I/O）模型是同步I/O，在这个模型中，当请求发出后，应用程序就会阻塞，知道请求满足

异步I/O：I/O请求可能需要与其它进程产生交叠

Linux 系统中最常用的输入/输出（I/O）模型是同步 I/O

在这个模型中，当请求发出之后，应用程序就会阻塞，直到请求满足为止
调用应用程序在等待 I/O 请求完成时不需要使用任何中央处理单元（CPU）
在某些情况下，I/O 请求可能需要与其他进程产生交叠，可移植操作系统接口（POSIX）异步 I/O（AIO）应用程序接口（API）就提供了这种功能
9.4.1.1 AIO系列API：

aio_read–异步读 
作用：请求对一个有效的文件描述符进行异步读写操作 
请求进行排队之后会立即返回
这个文件描述符可以表示一个文件、套接字，甚至管道
参数aiocb：结构体包含了传输的所有信息，以及为AIO操作准备的用户空间缓存区
返回值 
成功：返回0
失败：返回-1，并设置errno的值
int aio_read( struct aiocb *aiocbp );
aio_write–异步写 
作用：请求一个异步写操作 
请求进行排队之后会立即返回
这个文件描述符可以表示一个文件、套接字，甚至管道
参数aiocb：结构体包含了传输的所有信息，以及为AIO操作准备的用户空间缓存区
返回值 
成功：返回0
失败：返回-1，并设置errno的值
int aio_write( struct aiocb *aiocbp );
aio_error 
作用：确定请求的状态
参数aiocb：结构体包含了传输的所有信息，以及为AIO操作准备的用户空间缓存区
返回值 
EINPROGRESS：说明请求尚未完成
ECANCELED：说明请求被应用程序取消
失败：返回-1，并设置errno的值
int aio_error( struct aiocb *aiocbp );
aio_return–获得异步操作的返回值 
异步 I/O 和标准块 I/O 之间的另外一个区别是不能立即访问这个函数的返回状态，因为并没有阻塞在 read()调用上
在标准的 read()调用中，返回状态是在该函数返回时提供的。但是在异步 I/O 中，我们要使用 aio_return()函数
只有在 aio_error()调用确定请求已经完成（可能成功，也可能发生了错误）之后，才会调用这个函数
参数aiocb：结构体包含了传输的所有信息，以及为AIO操作准备的用户空间缓存区
返回值 
成功：返回所传输的字节数
失败：返回-1
ssize_t aio_return( struct aiocb *aiocbp );
aio_suspend–挂起异步操作，直到异步请求完成为止 
作用：挂起（或阻塞）调用进程，直到异步请求完成为止，调用者提供了一个 aiocb 引用列表，其中任何一个完成都会导致 aio_suspend()返回
int aio_suspend( const struct aiocb *const cblist[], int n, const struct timespec *timeout );
aio_cancel–取消异步请求 
作用：允许用户取消对某个文件描述符执行的一个或所有 I/O 请求
要求： 
如果要取消一个请求，用户需提供文件描述符和 aiocb 引用 
函数返回AIO_CANCELED：请求被成功取消
函数返回AIO_NOTCANCELED：请求完成
如果要取消对某个给定文件描述符的所有请求，用户需要提供这个文件的描述符以及一个对 aiocbp 的 NULL 引用 
函数返回AIO_CANCELED：表明所有的请求都取消了
函数返回AIO_NOTCANCELED：表明至少有一个请求没有被取消
函数返回AIO_ALLDONE：表明没有一个请求可以被取消
使用 aio_error()来验证每个 AIO 请求 
aio_error()返回-1并且设置了errno被设置为ECANCELED：表明某个请求已经被取消了
int aio_cancel( int fd, struct aiocb *aiocbp );
lio_listio–同时发起多个传输（一次系统调用可以启动大量的I/O操作） 
作用：这个函数非常重要，它使得用户可以在一个系统调用（一次内核上下文切换）中启动大量的 I/O 操作
参数 
mode：可以是 LIO_WAIT 或 LIO_NOWAIT 
LIO_WAIT 会阻塞这个调用，直到所有的 I/O 都完成为止
在操作进行排队之后，LIO_NOWAIT 就会返回
list ：是一个 aiocb 引用的列表，最大元素的个数是由 nent 定义的 
如果 list 的元素为 NULL，lio_listio()会将其忽略。
int lio_listio( int mode, struct aiocb *list[], int nent, struct sigevent *sig );
9.4.2 Linux内核AIO与libaio

linux AIO也可以由内核空间实现，异步I/O是linux2.6以后版本内核的标准特性
对于块设备，AIO可以一次性发出大量的read/write调用并且通过通用块层的I/O调度来获得更好的性能，用户也可以减少过多的同步负载
对网络设备而言，在socket层面上，也可以使用AIO，让CPU和网卡的收发充分交叠以改善吞吐性能
用户空间中一般要结合libaio来进行内核AIO的系统调用
io_setup( )

//Initializes an asynchronous context for the current process

io_submit( )

//Submits one or more asynchronous I/O operations

io_getevents( )

//Gets the completion status of some outstanding asynchronous I/O operations

io_cancel( )

//Cancels an outstanding I/O operation

io_destroy( )

//Removes an asynchronous context for the current process

9.4.3 AIO与设备驱动

用户空间调用io_submit()之后，对应于用户传递的每个iocb结构，内核会生成一个与之对应的kiocb结构
通过is_sync_kiocb判断某kiocb是否为同步I/O请求

如果是返回真，表示为异步I/O请求
字符设备：必须明确应支持AIO（极少数是异步I/O操作）

字符设备驱动程序中file_operations 包含 3 个与 AIO 相关的成员函数，
ssize_t (*aio_read) (struct kiocb *iocb, char *buffer, size_t count, loff_t offset);

ssize_t (*aio_write) (struct kiocb *iocb, const char *buffer, size_t count, loff_t offset);

int (*aio_fsync) (struct kiocb *iocb, int datasync);
块设备和网络设备：本身是异步的

《Linux4.0设备驱动开发详解》笔记--第十章：Linux设备驱动中的中断与时钟

2016年05月20日 13:44:09 zcj仲从建 阅读数 1617
版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/z1106609486/article/details/51461072
10.1 中断与定时器

分类 
中断来源 
内部中断 
来源于CPU的内部（软件中断的指令、溢出、除法错误等）
外部中断
来源于外设请求
是否可屏蔽 
可屏蔽中断
不可屏蔽中断
中断的入口方式 
向量中断 
CPU给每个不同的中断分配不同的中断号，中断发生时会自动跳到该中断号对应的地址执行
非向量中断 
多个中断共享一个入口地址，进入该入口后通过软件判断中具体哪个中断
ARM渡河处理器里最常用的中断控制器是GIC，它支持三种类型的中断 
SGI：软件产生的中断，可用于多核间通信，一个CPU可以通过写GIC寄存器给另一个CPU产生中断
PPI：某个CPU私有外设的中断，这类外设中断只能发给一个CPU
SPI：共享外设中断，这类外设的中断可以路由到任何一个CPU
ARM Linux默认情况下，中断都是由CPU0上产生的
10.2 Linux的中断处理程序架构

中断分层 
顶半部 
简单地读取寄存器中中断状态，并处理中断标志后就进行“登记中断”的工作 
“登记中断”：将底半部放在该设备的底半部执行队列中，以加快顶半部的执行速度
底半部 
处理中断程序的所有事情，可被中断打断
中断要处理的任务较少时可以所有的处理任务放到顶部处理
cat /proc/interrupts 
获得中断的统计信息，并且能统计出每个中断号发生的次数
10.3 Linux中断编程

10.3.1 申请和释放中断

1、申请irq

int request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags, const char *name, void *dev);
1
request_irq()函数 
参数 
irq：申请的硬件中断号
handler：向系统登记的中断处理函数，是一个回调函数
irqflags：中断处理属性 
中断触发方式 
IRQ_TRIGGER_RISING
IRQF_TRIGGER_FALLING
IRQF_TRIGGER_HIGH
IRQF_TRIGGER_LOW
中断处理方式 
IRQF_shared：多个设备共享中断
dev：传递给中断服务程序的私有数据，一般为设备结构体或者NULL
返回值 
成功：返回0
失败： 
返回-EINVAL：中断号无效或者中断处理函数为NULL
返回-EBUSY：中断已经被占用且不能共享
int devm_irq_irq(struct devcice* dev, unsigned int irq, irq_handler_t handler, unsigned long irqflags, const char *devname, void *dev_id);
1
devm_request_irq()函数 
与request_irq()函数区别：devm_开头的API申请的是内核“managed”的资源，一般不需要在出错的地方处理和在remove()接口里面在显示的释放
10.3.2 使能和屏蔽中断

屏蔽一个中断源 
disable_irq_nosync()：立即返回
disable_irq()：等待目前的中断处理完成 
因为desable_irq()函数会等待指定的中断被处理完成，因此如果在n号中断的顶半部调用disable_irq(n)，会引起系统的死锁，这种情况下只能调用disable_irq_nosync(n)
void disable_irq_irq(int irq);
void disable_irq_nosync(int irq);
void enable_irq(int irq);
1
2
3
屏蔽本CPU上的全部中断 
local_irq_save()函数：会将中断的状态保留在flags中 
flags为unsigned long类型，被直接传递，而不是通过指针
local_irq()函数直接禁止中断而不保存状态
#define local_irq_save(flag) ...
void local_irq_disable(void);
1
2
恢复本CPU上的全部中断
#define local_irq-restore(flags) ...
void local_irq_enable(void);
1
2
10.3.3 底半部机制

Linux实现底半部机制主要有tasklet、工作队列、软中断和线程化irq
tasklet 
tasklet执行的上下文是软中断，执行的时机是顶半部返回的时候
实际的操作是：定义tasklet及其处理函数，并将两者关联 
DECLARE_TASKLET：实现了定义名称为my_tasklet的tasklet，并将其与my_tasklet_func()这个函数绑定，而传入这个函数的参数为data
在调度tasklet的时候引用一个tasklet_schedule()函数
void my_tasklet_func(unsigned long);//定义一个处理函数

//定义一个tasklet结构my_tasklet, 与my_tasklet_func(data)函数相关联
DECLARE_TASKLET(my_tasklet, my_tasklet_func, data);

tasklet_schedule(&my_tasklet);
1
2
3
4
5
6
工作队列 
使用方法和tasklet相似，如下：
struct work_struct my_wq; //定义一个工作队列

void my_wq_func(unsigned long);  //定义一个处理函数

INIT_WORK(&my_wq, (void (*)(void *))my_wq_func, NULL);  //初始化工作队列并将其与处理函数绑定

schedule_work(&my_irq)；//系统在适当的时候需要调度时使用运行
1
2
3
4
5
6
7
软中断 
使用软件方式模拟硬件中断的概念，实现宏观上的异步执行效果
软中断和tasklet仍然运行与中断上下文，而工作队列则运行于进程上下文，因此软中断和tasklet的处理函数不能休眠，但工作队列是可以的。
softirq_action结构体表征一个软中断 
这个结构体中包含软中断处理函数指针和传递给函数的参数
open_softirq()可以注册软中断对应的处理函数
raise_softirq()函数可以触发一个中断
local_bh_disable()和local_bh_enable()是内核用于禁止和使能软中断和tasklet底半部机制的函数。
threaded_irq 
内核申请中断的新函数 
request_threaded_irq();
devm_request_threaded_irq(); 
新的函数比request_irq()函数和devm_request_irq()函数多了个thread_fn参数
这两个函数申请中断的时候，内核会为相应的中断号分配一个对应的内核线程，这个线程指针对这个中断号
这两个函数支持在irqflags中设置IRQF_ONESHOT标志，这样内核会自动在中断上下文中屏蔽对应的中断号，而在内核调度thread_fn执行后，重新是能该中断号
参数 
handler对应的函数执行于中断上下文
thread_fn参数对应的函数执行于内核线程
如果handler结束的时候，返回值是IRQ_WAKE_THREAD，内核会调度线程执行thread_fn对应的函数
handler参数可以设置为NULL，此时内核会默认的irq_default_primary_handler()代替handler，并会使用IRQF_ONESHOT标志
int request_threaded_irq(unsigned int irq, irq_handler_t handler, irq_handler_t thread_fn, unsigned long flags, const char*name, void *dev);

int devm_request_threaded_irq(struct device *dev, unsigned int irq, irq_handler_t handler, irq_handler_t thread_fn, unsignd long irqflags, const char *devname, void *dev_id);

static irqreturn_t irq_default_primary_handler(int irq, void *dev_id)
{
    return IRQ_WAKE_THREAD;
}
1
2
3
4
5
6
7
8
10.4 中断共享

共享中断的多个设备申请中断时，都应该使用IRQF_SHARED标志，申请成功的前提： 
该中断未被申请
该中断虽然被申请了，但是之前申请的该中断的所有设备也都以IRQF_SHARED标志申请该中断
尽管内核模块可以访问的全局地址都可以作为request_irq(…，void *dev_id)的最后一个参数dev_id，但是设备结构体指针显示可传入的最佳参数
中断到来时，会遍历执行共享此中断的所有中断处理程序，直到某个函数返回IRQ_HANDLED 
在中断处理程序顶半部中，应根据硬件寄存器中的信息比照传入的dev_id参数迅速判断是否为本设备的中断，若不是，应迅速返回IRQ_NONE
10.5 内核定时器

10.5.1 内核定时器编程

1、timer_list结构体

内核定时器的数据结构 
定时器期满后，function()成员将被执行 
data成员是其传入的参数
expires成员是定时器的到期时间（jiffies）
struct timer_list {
    struct list_head entry;

    unsigned long expires;
    void (*function)(unsigned long);
    unsigned long data;

    struct tvec_base *base;
    /* ... */
};
1
2
3
4
5
6
7
8
9
10
定义一个名为my_timer的定时器
struct timer_list my_timer;
1
2、初始化定时器

init_timer是一个宏，用来初始化timer_list的entry的next为NULL，并给base指针赋值
void init_timer(struct timer_list *timer);
1
TIMER_INITALIZER(_function，_expires, _data)宏用于赋值定时器结构体的function、expires、data和base成员
DEFINE_TIMER(_name,_function,_expires,_data)宏是定义并初始化定时器成员的“快捷方式”
setup_timer()也可以用于初始化定时器并赋值其成员
3、增加定时器

注册内核定时器，将定时器加入到内核的动态定时器链表中
void add_timer(struct timer_list *timer);
1
4、删除定时器

del_timer_sync()是del_timer的同步版，在删除一个定时器时需要等待其被处理完，因此该函数的调用不能发生在中断上下文中
int del_timer(struct timer_list *timer);
1
5、修改定时器

mod_timer()函数修改定时器的到期时间，在新的被传入的expires到来后才会执行定时器函数
int mod_timer(struct timer_list *timer, unsigned long expires);
1
6、定时器的使用流程

-----------使用定时器的步骤--------------
struct timer_list  my_timer_list;//定义一个定时器，可以把它放在你的设备结构中 struct{定义一个定时器}
init_timer(&my_timer_list);//初始化一个定时器
my_timer_list.expire=jiffies+HZ;//定时器1s后运行服务程序
my_timer_list.function=timer_function;//定时器服务函数
add_timer(&my_timer_list);//添加定时器
void timer_function(unsigned long)//写定时器服务函数
del_timer(&my_timer_list);//当定时器不再需要时删除定时器
del_timer_sync(&my_timer_list);//基本和del_timer一样，比较适合在多核处理器使用，一般推荐使用del_timer_sync
1
2
3
4
5
6
7
8
9
10.6 内核延时

10.6.1 短延时

内核提供的纳秒、微妙和毫秒的延时 
忙等待，根据CPU的频率进行一定次数的循环
毫秒延时对内核来说是很大的，最好不要直接用，可以用替代性函数
void ndelay(unsigned long nsecs);
void udelay(unsigned long usecs);
void mdelay(unsigned long msecs);

//毫秒延时的替代性函数
vooid msleep(unsigned int millisecs);
unsigned long msleep_interruptible(unsigned int millisecs);
void ssleep(unsigned int seconds);
1
2
3
4
5
6
7
8
10.6.2 长延时

比较当前的jiffies和目标jiffies，直到未来的jiffies到达目标jiffies
time_before()与time_after()函数：将传入的未来时间jiffies和被调用时的jiffies进行一个简单的比较 
为了防止在比较过程中编译器对jiffies的优化，内核将其定义为volatile变量，这将保证每次都会重新读取这个变量
//延迟100个jiffies
unsigned long delay = jiffies +100;
while(time_before(jiffies, delay));
//在延迟2s
unsigned long delay = jiffies + 2*Hz;
while(time_before(jiffies, delay));
1
2
3
4
5
6
10.6.3 睡着延时

睡着延时：是在等待的时间到来之前进程处于睡眠状态，CPU资源被其他的进程使用
schedule_timeout()可以使当前任务休眠至指定的jiffies之后再重新被调用执行 
schedule_timeout的实现原理是向系统添加一个定时器，在定时器处理函数中唤醒与参数对应的进程
下面函数可以将当前进程添加到等待队列中，从而在等待队列上睡眠，当超时发生时，进程将它们唤醒
sleep_on_timeout(wait_queue_head_t *q, unsigned long timeout);
interruptible_sleep_on_timeout(wait_queue_head_t *q, unsignd long timeout);

《Linux4.0设备驱动开发详解》笔记--第十一章：内存与I/O访问

2016年05月20日 13:45:10 zcj仲从建 阅读数 1952
版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/z1106609486/article/details/51461080
由于Linux系统提供了复杂的内存管理功能，所以内存的概念在Linux系统中的相对复杂，有常规的内存、高端的内存、虚拟地址、逻辑地址、总线地址、物理地址、I/O内存、设备内存、预留内存等概念
11.1 CPU与内存、I/O

11.1.1 内存空间与I/O空间

I/O空间:在X86处理器中存在着I/O空间的概念，I/O空间是相对于内存空间而言的
它通过特定的指令in、out来访问
指令格式:IN 累加器,{端口号|DX}
OUT {端口号|DX},累加器
1
2
注意:目前大多数嵌入式微控制例如ARM、PowerPC等不提供I/O空间，而仅存在内存空间。 内存空间可以直接通过地址、指针来访问
11.1.2 内存管理单元MMU

作用:辅助操作系统进行内存管理，提供虚拟地址和物理地址的映射、内存访问权限保护和Cache缓存控制等硬件支持。
虚拟内存机制可以让用户感觉好像程序可以使用非常大的内存空间

MMU操作原理:

TLB：转换旁路缓存，是MMU的核心部件，缓存少量虚拟地址和物理地址的转换关系，是转换表的Cache，也成为快表
TTW：转换表漫游，当TLB中没有对应缓冲对应的地址转换关系时，需要通过对内存中转换表(一般为多级页表)的访问来得到虚拟地址和物理地的对应关系。TTW成功后，会将对应的转换关系写入TLB，方便下次转换 
若TLB中没有虚拟地址的入口，则转换表遍历硬件从存放于主存储器的转换表中获取地址转换信息和访问权限(也就是获得TTW啦),同时将信息放入TLB，它或者被放在一个没有使用的入口或者替换一个已经存在的端口，以后当再次访问这些地址时，对真是物理地址的访问将在Cache或者在内存中发生
ARM中的TLB条目中的控制信息用于控制对对应地址的访问权限及Cache的操作 
C(高速缓存)和B(缓冲)位被用来控制对应地址的高速缓存和写缓冲，并决定是否进行告诉缓存
访问权限和域位作用用来控制读写访问是否被允许，如果不允许将发送一个异常
11.2 Linux内存管理

Linux系统中，进程4GB的内存空间被分成两个部分:用户空间和内核空间 
用户空间地址:0~3GB
内核空间地址:3~4GB
用户进程通常只能访问用户空间的虚拟地址，不能访问内核空间的虚拟地址 
用户进程只有通过系统调用的方式才能访问到内核空间
内核空间与用户空间的区别: 
每个进程的用户空间都是完全独立的用户进程各自拥有不同的页表
内核空间是由内核负责映射的，它不会跟着进程改变，是固定的
内核地址空间有自己独立的页表
Linux内核空间(1GB)的划分: 
常规内存:
物理内映射区(896MB):系统物理内存被顺序映射在内核空间的这个区域
高端内存:
虚拟内存分配区(其实地址:VMALLOC_START~VMALLOC_END,用vmalloc()函数分配)
高端页面映射区(起始地址:PKMAP_BASE)
专用页面应设置区(地址为FIXADDR_START~FIXADDR_TOP) 系统保留映射区
物理内存超过4GB的处理办法 
此时必须使用CPU的扩展分页(PAE)模式提供的64位页目录才能取到4GB以上的物理内存
11.3 内存读取:

11.3.1 用户空间内存动态申请

申请:malloc()
释放:free()
11.3.2 内核空间内存动态申请

1、相关函数关系:

kmalloc()与 - __get_free_pages() 
kmalloc()和__get_free_pages()申请的内存位于物理内存映射区，并且是连续的，它与真实的物理地址一般只差一个固定的偏移
vmalloc() 
vmalloc()在虚拟地址空间给出一块连续的内存区，实质上这段连续的虚拟内存在物理内存中并不一定连续。也没简单的换算关系
2、具体函数详解

kmalloc(size_t size,int flags); 
参数 
size:分配大小
flag:分配标识 
GFP_KERNEL(最常用)，在内核空间进程中申请内存
GFP_USER，用来为用户空间分配内存，可能阻塞
GFP_HINSTANCE,与GFP_USER类似但是是从高端内存分配
GFP_NOIO,不允许任何IO初始化
GFP_NOFS，不允许任何文件系统调用
__GFP_DMA,要求分配在能够DMA的内存区
__GFP_HINSTANCE，指示分配的内存区可以位于高端内存
注意：kmalloc()其实就是依赖于_get_free_pages()函数实现的
__get_free_pages(unsigned int flags,unsigned int order); 
介绍:此宏是Linux内核本质上最底层用于获取空闲内存的方法 
因为底层的伙伴算法总是以页的2的n次方为单位管理空闲内存，所以最底层的内存申请总是以页为单位的
参数 
order:分配的页数是2^order
flags:同kmalloc
相关宏 
get_zeroed_pages()(申请的同时将页清空)
__get_free_page()(申请一页，不清零) 
上述两个宏在实现中调用了alloc_pages()函数 
alloc_pages()既可以在内核空间分配，也可以在用户空间分配
对应的释放函数：free_page(s)()
__get_free_pages(unsigned int flags,unsigned int order);
get_zeroed_page(unsigned int flags);
__get_free_page(unsigned int flags);

struct page*alloc_pages(int gfp_mask,unsigned long order);

//__get_free_pages()函数对应的释放函数
void free_page(unsigned long addr);
void free_pages(unsigned long addr,unsigned long order);
1
2
3
4
5
6
7
8
9
vmalloc函数 
使用情况 
一般只为存在于软件中（没有对应的硬件意义）的较大的顺序缓存区分配内存，其远大于__get_free_pages()的开销
其不能用于原子上下文中 
因为其内部实现使用了标志为GFP_KERNEL的kmalloc()
vmalloc()的虚拟地址和物理地址不是一个简单的线性映射 
因为vmolloc()在申请内存时，会进行内存的映射，改变页表项
void *vmalloc(unsigned long size);
void vfree(void *addr);
1
2
slab与内存池: 
引入slab的原因: 
完全使用页为单元申请和释放内存容易导致浪费
在操作系统的运行过程中，经常涉及到对大量对象的重复生成、使用和释放问题，此时使用slab可以大大提高效率
实际上kmalloc()就是使用slab机制实现的
使用方法: 
创建一个slab缓存：kmem_cache_create() 
它可以保留任意数目且全部同样大小的后备缓存
参数 
size：要分配的每个数据结构的大小
flags：控制如何进行分配的位掩码 
SLAB_HWCACHE_ALIGN：每个数据对象呗对齐到一个缓存行
SLAB_CACHE_DMA：要求数据对象在DMA区域中的分配
分配slab缓存：kmem_cache_alloc(); 
创建的slab后备缓存中分配一块并返回首地址指针
释放slab缓存：kmem_cache_free(); 
释放由kmem_cache_alloc()函数分配的缓存
收回slab缓存：kmem_cache_destroy();
获知当前的slab的分配和使用情况：cat /proc/slabinfo
注意：slab不是要替代__get_free_pages(),其在最底层仍然依赖于__get_free_pages()，slab在底层每次申请1页或多页，之后在分隔这些页为更小的单元进行管理，从而节省了内存，也提高了slab缓冲对象的访问效率
//1.创建slab缓存
struct kmem_cache *kmem_cache_create(const char *name, size_t size, size_t align, unsigned long flags,
void (*ctor)(void*, struct kmem_cache*, unsigned long),
void (*dtor)(void*,struct kmem_cache*, unsigned long));
//2.分配slab缓存
void *kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags);
//3.释放slab函数
void kmem_cache_free(struct kmem_cache *cachep, void objp);
//4.收回slab缓存
int kmem_cache_destroy(struct kmem_cache *cachep);

//slab缓存使用范例:
//创建slab缓存
static kmem_cache_t *xxx_cachep;
xxx_cachep = kmem_cache_create("xxx", sizeof(struct xxx), 0, SLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL, NULL);
//分配slab缓存
struct xxx *ctx;
ctx = kmem_cache_alloc(xxx_cachep, GFP_KERNEL);
...
//释放slab缓存
kmem_cache_free(xxx_cachep, ctx);
kmem_cache_destroy(xxx_cachep);
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
内核中，与内存池相关的操作包括以下几种 
创建内存池：mempool_create(); 
参数 
min_nr参数是需要预分配对象的数目
alloc_fn和free_fn是指向内存池基础值提供的标准对象分配和回收函数的指针 
其原型分别为 
mempool_alloc_t(); 
参数 
pool_data：分配和回收函数用到的指针
gfp_mask：是分配标志，只有当__GFP_WAIT标志被指定时，分配函数才会休眠
mempool_free_t();
分配和回收函数 
mempool_alloc(); 
用来分配对象，如果内存池分配器无法提供内存，那么久可以用预分配的池
mempool_free();
回收内存池：mempool_destroy(); 
由mempool_create()函数创建的内存池需要mempool_destroy()函数释放
//1.创建内存池
mempool_t *mempool_create(int min_nr, menpool_alloc_t *alloc_fn, menpool_free_t * free_fn, void *pool_data);
//内存池机制提供的标准对象分配和回收函数指针的原型分别为
typedef void *(mempool_alloc_t)(int gfp_mask, void *pool_data);
和
typedef void (mempool_free_t)(void *element, void *pool_data);
//2.分配和回收对象
void *mempool_alloc(mempool_t, int gfp_mask);
void mempool_free(void *element, mempool_t *pool);
//3.回收内存池
void mempool_destroy(mempool_t *pool);
1
2
3
4
5
6
7
8
9
10
11
11.4 设备I/O端口和I/O内存的访问

设备通常提供一组寄存器来控制设备，读写设备和获取设备状态，及控制寄存器、数据寄存器和状态寄存器。这些寄存器可能位于I/O空间中，也可能位于内存空间中。当位于I/O空间时候，通常称为I/O端口；但位于内存空间时，对应的内存空间称为I/O内存
11.4.1 Linux I/O端口和I/O内存访问接口

1. I/O端口

Linux内核提供的访问位于I/O空间的端口 
丅述个函数中I/O端口号port高度依赖于具体的硬件平台，因此，这里只写出了unsigned
//1.读写字节端口（8位）
unsigned inb(unsigned port);
void outb(unsigned char byte, unsigned port);
//2.读写字端口
unsigned inw(unsined port);
void outw(unsigned short word, unsigned port);
//3.读写长字端口
unsigned inl(unsigned port);
void outl(unsigned longword, unsigned port);
//4.读写一串字节
void insb(unsigned port, void *addr, unsigned long count);
void outsb(unsigned port, void *addr, unsigned long count);
//5.insb()从端口port开始读count个字节端口，并将读取结果接入addr指向的内存；outsb()将addr指向的内存中的count个字节连续的写入以port开始的端口
//6.读写一串字
void insw(unsigned port, void *addr unsigned long count);
void outse(unsigned port, void *addr, unsignd long count);
//7.读写一串长字
void insl(unsigned port, void *addr, unsigned log count);
void outsl(unsigned port, void *addr, unsigned long count);
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
2. I/O内存

I/O内存通常是芯片内部的哥哥I2C、SPI、USB等控制器的寄存器后者外部内存总线的设备。在访问I/O内存之前首先要做的是将设备所处的物理地址映射到虚拟地址。
//将物理地址映射到虚拟地址
void *ioremap(unsigned long offset,unsigned long size)
//释放
void ionumap(void * addr);
//ioremap()函数的变体函数devm_ioremap()，它不需要再驱动退出或者出错的时候进行iounmap().
void __iomem *devm_ioremap(struct device* dev, resource_size_t offset, unsigned long size);
1
2
3
4
5
6
在设备地址被映射到虚拟地址之后，尽管可以直接通过指针访问这些地址，但是Linux内核推荐使用一组标准的API开完成设备内存映射的虚拟地址的读写
I/O内存读写操作: 
没有_relaxed后缀的版本与有_relaxed后缀的版本的区别是没有_relaxed后缀的版本包含一个内存屏障
//1.读I/O内存
#define readb(c)   ({u8 __v = readb_relaxed(c);__iomb();__v;})
#define readw(c)   ({u16 __v = readb_relaxed(c);__iomb();__v;})
#define readl(c)   ({u32 __v = readb_relaxed(c);__iomb();__v;})
//2.写I/O内存
#define writeb(v,c)   ({u8 __v = readb_relaxed(c);__iomb();__v;})
#define readw(v,c)   ({u16 __v = readb_relaxed(c);__iomb();__v;})
#define readl(v,c)   ({u32 __v = readb_relaxed(c);__iomb();__v;})
1
2
3
4
5
6
7
8
11.4.2 申请和释放设备I/O端口和内存

1. I/O端口申请

linux内核提供一组函数申请和释放I/O端口，表明该驱动要访问这片区域 
申请：request_region() 
这个函数向内核申请n个端口，这些端口从first开始，name参数为设备的名字
返回值 
成功：返回非NULL
失败：返回NULL
释放I/O端口：release_region()
struct resource *request_region(unsigned long first,unsigned long n,const char*name);

void release_region(unsigned long start,unsigned long n);
1
2
3
2. I/O 内存申请

Linux内核已提供了一组函数以申请和释放I/O内存的范围，此处的“申请”表明，该驱动要访问这片区域，他不会做任何内存映射的动作 
内存申请：request_mem_region() 
这个函数向内核申请n个内存地址，这个地址从first开始，name是设备参数的名称
返回值 
成功：返回值非NULL
失败：返回NULL
内存释放：release_mem_region()
struct resource *request_mem_region(unsigned long start, unsigned long len, char *name);

void release_mem_region(unsigned long start, unsigned long len);
1
2
3
11.4.3 设备I/O端口和I/O内存访问流程

I/O端口的访问: 
request_region()：在设备打开或驱动模块被加载时申请I/O端口区域
inb()/outb()：使用inb()、outb()等函数进行访问
release_region()：在设备关闭或驱动被卸载时释放I/O端口范围
I/O内存访问步骤 
request_mem_region()：首先申请资源
ioremap()：将寄存器地址通过映射到内核空间虚拟地址
readb/readl/writeb/writel：通过这些函数访问设备的寄存器
iounmap()+release_mem_region()：访问完成之后，对ioremap()申请的虚拟地址进行释放，并释放release_mem_region()申请的I/O内存资源
11.4.4 将设备地址映射到用户空间

1.内存映射与VMA

一般情况下用户空间是不能也不应该直接访问设备但是我们可以通过在设备驱动程序中实现mmap()函数，这个函数可以使得用户空间能直接访问物理设备
mmap() 
函数的实质 
将用户空间的一段内存与设备内存关联，当用户访问用户空间的这段地址范围时，实际上会转化为对应的设备的访问。
mmap()函数必须以页为单位进行映射
驱动程序mmap()的实现机制也是建立页表
驱动中的mmap()函数将在用户空间进行mmap()系统调用时被调用
参数 
fd：文件描述符
len：是映射到用户空间的字节数
prot：指定访问权限 
PROT_READ
PROT_WRITE
PROT_EXEC
PROT_NONE
caddr:指定文件应该被映射的起始地址，一般被指定为NULL，由内核分配
//驱动中mmap()函数原型:
int (*mmap)(struct file *,struct vm_area_struct *);

//用户空间的mmap()函数原型:
caddr_t mmap(caddr_t addr,size_t len,int prot,int flags,int fd,off_t offset);
1
2
3
4
5
用户调用mmap()时所进行的工作 
(1) 在进程的虚拟地址空间查找一块VMA
(2) 将这块VMA进行映射
(3) 如果设备驱动程序或者文件系统的file_operations定义了mmap()操作则调用它
(4) 将这个VMA插入到进程的VMA表中
VMA结构体 
虚拟地址的描述通过VMA结构体来实现
VMA结构体描述的虚拟地址位于vm_start ~vm_end之间
struct vm_area_struct
{
struct mm_struct *vm_mm;/*所处的地址空间*/
unsigned long vm_start;/*开始虚拟地址*/
unsigned long vm_end;/*结束虚拟地址*/


pgprot_t vm_page_prot;/*访问权限*/
unsigned long vm_flags;/*标识，VM_READ,WM_WRITE,VM_EXEC,VM_SHARED*/
...
/*VMA的函数的指针*/
struct vm_operations_struct *vm_ops;


unsigned long vm_pgoff;/*偏移(页帧号)*/
struct file *vm_file;
void *vm_private_data;
....

};
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
vm_operations_structk结构体 
此结构体描述了对VMA的相关操作
当用户进行系统调用mmap()后，内核不会调用VMA的open函数， 
通常需要在驱动的mmap()函数中显示调用vma->vm_ops->open()
struct vm_operations_struct{
    void(*open)(struct vm_area_struct *area);/*打开vma的操作*/
    void (*close)(..)
    struct page*(nopage)(...)/*访问的页不存在时调用*/
    ...
};
1
2
3
4
5
6
vm_operations_struct操作范例 
重要函数 
remap_pfn_range() 
作用 
用来创建页表项 
以VMA结构体的成员作为remap_pfn_range()的参数 
VMA的数据成员是内核根据用户的请求自己填充的
映射的虚拟地址范围是vma->vm_start至vma->vm_end
映射内存中的保留页、设备I/O、framebuffer、camera等内存
参数 
addr:表示内存映射开始处的虚拟地址
pfn:是虚拟地址应该映射到的物理地址的页帧号 
实际上就是物理地址右移PAGE_SHIFT位
页帧号：内核地址无论是虚拟的还是物理的，都是由两部分构成，往往是高N位为页号，低M位为页内偏移量。当我们将地址中的低M位偏移量抛弃时，高N位移动到右端得到这个结果称为页帧号，宏PAGE_SHIFT告诉我们要右移多少位才能得到页帧号
port：新页所要求的保护属性
static int xxx_map(struct file*filp,struct vm_area_struct *vma)
{
   /*建立页表*/
    if(remap_pfn_range(vma,vma->start,vm->vm_pgoff,
    vm->vm_end-vma->start,vma->page_prot))
    return -EAGAIN;

    vma->ops = &xxx_remap_vmops;
    xxx_vma_open(vma);
    return 0;
}

/*vma打开函数*/
void xxx_vm_open(struct vm_area_struct *vma)
{
    ...
    printk(KERNEL "xxx VMA open,virt %1x,phys %1x\n",vma->vm_start,
    vma->vm_pgoff<<PAGE_SHIFT);
}

/*vma关闭函数*/
void xxx_vma_close(struct vm_area_struct *vma)
{
    ...
    printk(KERN_NOTICE "xxx VMA close.\n");
}

static struct vm_operations_struct xxx_remap_vm_ops = {
    /*VMA操作结构体*/
    .open =  xxx_vm_open,
    .close = xxx_vma_close,
    ...
};
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
//remap_pfn_range函数原型
remap_pfn_range(struct vm_area_struct *vma,unsigned long addr,unsigned long pfn,unsigned long size,pgprot_t prot);
1
2
例程：映射kmalloc申请的内存到用户空间 
注意：通常I/O内存被映射时需要nocahe的，这个时候需要对vma_page_prot设置nocache标识之后再进行映射

/*内核模块加载函数*/
int __init kmalloc_map_init(void)
{
    ...
    /*申请设备号
    添加cdev结构体*/
    buffer = kmalloc(BUFSIZE,GFP_KERNEL);//申请buffer

    /*virt_to_page,获取对应的虚拟页*/
    for(page = virt_to_page(buffer);
    page<vir_to_page(buffer+BUFSIZE);
    page++)
    mem_map_reverse(page);/*设置为保留页*/
}

/*mmap()函数*/
static int kmalloc_map_mmap(struct file*filp,struct vm_area_struct *vma)
{
    unsigned long page,pos;
    unsigned long start = (unsigned long)vma->vm_start;
    unsigned long size  = (unsigned long)(vma->vm_end-vma->vm_start);
    printk(KERNEL_INFO "mmaptest_mmap called\n");

    /*用户要映射的区域太大*/
    if(size>BUFSIZE)
    return -EINVAL;

    pos = (unsigned long)buffer;
    /*映射buffer中的所有页*/
    while(size > 0){
    /*每次映射一页*/
    page = virt_to_phys((void *)pos);//先将在内核中用malloc分配的空间转换为对应的物理页地址
    if(remap_page_range(start,page,PAGE_SIZE,PAGE_SHARED));/*将物理页地址映射到vma，并且每次只映射一页*/
    return - EAGAIN;
    start += PAGE_SIZE;
    pos +=PAGE_SIZE;
    size -=PAGE_SIZE;
    }return 0;
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
2. fault()函数

简介:除了remap_pfn_range函数以外，在驱动程序中实现VMA的fault()函数可以为设备提供，更加灵活的映射途径，当访问的页不存在(发生缺页异常)时，fault()会被内核自动调用
当发生缺页异常时系统做出的响应: 
(1).找到缺页的虚拟地址所在的VMA
(2).如果不要，分配中间页目录表和页表
(3).如果也表项不存在，调用VMA的nopage()方法，返回物理页面的描述符
(4).将物理页面的地址填充到页表中
fault()函数使用范例
static int xxx_fault(struct vm_area_struct *vm, struct vm_fault *vmf)
{
    unsigned log paddr;
    unsigned long pn;
    pgoff_t index = vmf->pgoff;
    struct vma_data *vdata = vma->vm_private_data;
    ...
    pfn = paddr >> PAGE_SHIFT;
    vm_inset_pfn(vam, (unsigned long)vmf->virtual_address, pfn);

    return VM_FAULT_NOPAGE;
}
1
2
3
4
5
6
7
8
9
10
11
12
11.5 I/O内存的静态映射

简介:假如我们已经做好目标电路板，而要将Linux移植到目标电路板，此时通常会建立外I/O内存物理地址到虚拟地址的静态映射，这个映射通过在与电路板对应的map_desc结构体数组中添加新的成员来完成
map_desc结构体
struct map_desc{
    unsigned long virtual;//虚拟地址
    unsigned long pfn;    //__phys_to_phn(phy_addr)
    unsigned long length; //大小
    unsigned int type;    //类型
};
1
2
3
4
5
6
11.6 DMA（重点）

DMA:是一种无序CPU帮助就可以让外设与系统之间进行双向数据传输的硬件机制简单点说就是这个样子 外设<———->内存 
而不是传统的 外设<—-cpu—–>内存
DMA与Cache的一致性问题:
假设DMA针对内存的目的地址与Cache缓存的对象有重叠区域，那么经过DMA操作后，Cache缓存对应的内存的数据就会被修改，而CPU却并不知道，它仍然会认为Cache中的数据就是内存中的数据，此时会产生Cache与内存之间的数据”不一致”错误
DMA与Cache的一致性实质
在采用Cache的系统中，同样一个数据可能存在于Cache中，也可能存在于主存中，当Cache中的数据与主存中的一样时则具有一致性，否则数据具有不一致性
出现Cache的一致性问题的情况 
DMA与Cache的一致性问题
Cache使能和关闭的时刻 
在具有MMU的ARM中，开启MMU前要先置Cache无效
11.6.2 Linux下的DMA编程

内存中用于与外设交互数据的一块区域被称为DMA缓冲区，一般情况下DMA在物理上连续的
1. DMA 区域

对于X86系统的ISA设备而言，DMA操作只能在16MB一下的内存中使用，因此在用kmalloc()和__get_free_pages()及类似的函数申请DMA缓冲区时应使用GFP_DMA标志，这样获得的DMA 
区域是具备DMA能力的
Linux内核已经把此操作为我们封装好了 
__get_dma_page()：它在申请时已经添加了GFP_DMA标志 
函数是以2^order为大小分配的DMA内存
#define __get_dma_pages(gfp_mask,order)\
__get_free_pages((gfp_mask)|GFP_DMA,(order))
1
2
如果不想用order为参数来申请DMA内存，则可以用下面的函数
static unsigend long dma_mem_alloc(int size);
1
注意：大多数嵌入式设备而言,DMA操作可以在整个常规内存区域进行，因此DMA区域就直接覆盖了常规的内存了
2.虚拟地址、物理地址和总线地址

基于DMA的硬件使用的是总线地址而不是物理地址 
总线地址:是从设备的角度上看到的内存地址 
物理地址:是从CPU MMU控制器外围角度上看到的内存地址
Linux内核提供如下函数用于简单的虚拟地址/总线地址的转换 
在使用IOMMU或反弹缓冲区的情况下，下述函数不会正常工作
这两个函数是不被建议使用的
unsigned long virt_to_bus(volate void *address);
void *bus_to_virt(unsigned long address);
1
2
3.DMA地址掩码

设备不一定在所有的内存地址上执行DMA操作，此时应该通过下列函数执行DMA地址掩码
int dma_set_mask(struct device*dev,u64 mask);
1
 - 例如:对于只能在24位地址上执行DMA操作的设备，就应该使用如下方法 dma_set_mask(dev,0xffffff)
1
该API的本质就是修改device结构体的dma_mask成员 
dma_mask：设备DMA可以寻址的范围
4.一致性DMA缓冲区

DMA缓冲区包括两个方面的工作: 
1.分配一片DMA缓冲区(为这片缓冲区产生设备可以访问的地址)
2.DMA映射必须考虑Cache一致性问题
内核提供如下函数用于分配就一个DMA一致性的内存区域 
ama_alloc_coherent()函数 
参数handle返回DMA缓冲区的总线地址，其类型为dma_addr_t，表示总线地址
返回值：为申请到的DMA缓冲区地址
void *ama_alloc_coherent(struct device *dev,size_t size,dma_addr_t handle,gfp_t gfp)
1
与ama_alloc_coherent()函数对应的释放函数
void dma_free_coherent(struct device *dev, size_t size, void *cpu_addr, dma_addr_t handle);
1
分配一个写合并的DMA缓冲区函数与其释放函数
void * dma_alloc_writecombine(struct device *dev, size_t size, dma_addr_t *handle, gfp_t gfp);

#definedma_free_writecombine(dev,size,cpu_addr,handle)  dma_free_coherent(dev,size,cpu_addr,handle)
1
2
3
PCI设备申请DMA缓冲区的函数
void * pci_alloc_consistent(struct pci_dev *pdev, size_t size, dma_addr_t *dma_addrp);

void pci_free_consistent(struct pci_dev *pdev, size_t size, void *cpu_addr, dma_addr_t dma_addr);
1
2
3
注意：dma_alloc_xxx()函数虽然是以dma_alloc_开头的，但是其申请 的区域比一定在DMA区域里面，例如，以32ARM为例，当coherent_dma_mask小于0xfffffff时，才会设置GFP_DMA标志，并从DMA区域去申请内存

CMA机制：不预留内存，这些内存平时是可用的，只有当需要的时候，才被分配给camera、HDMI等设备使用

其对上呈现的接口是标准的DMA，也是一致性缓冲区API
5. 流式DMA映射

并不是所有的DMA缓冲区的申请都是驱动申请的，如果是驱动申请的，用一致性的DMA缓冲区自然最方便，这直接考虑了DMA的一致性问题。但是，在许多情况下，缓冲区来自内核的上层（如网卡驱动中的网络报文、块设备驱动中要写入的数据等），上层很可能用普通的kmalloc()、__get_free_pages()等方法来申请，这时候就要使用流式DMA映射
流式DMA的工作步骤 
进行流式DMA映射
执行DMA操作
进行流式DMA去映射
流式DMA本质上是进行Cache的使无效或清除操作，以解决Cache的一致性问题

流式DMA映射的接口

实现DMA的映射函数：dma_map_single() 
参数 
direction：DMA的方向 
DMA_TO_DEVICE
DMA_FROM_DEVICE
DMA_BIDIRECTIONAL
DMA_NONE
返回值 
成功：返回总线的地址
失败：返回NULL
反映射函数：dma_unmap_single()
dma_addr_t dma_map_single(struct device *dev，void *bufer, size_t size, enum dma_data_direction direction);

void dma_unmap_single(struct device *dev, dma_addr_t dma_addr, size_t size, enum dma_data_direction direction);
1
2
3
6. dmaengine标准API

Linux内核目前推荐使用dmaengine的驱动来编写DMA控制器的驱动，同时外设的驱动使用标准的dmaengine API进行DMA的准备、发起和完成时的回调工作
在使用DMA前，设备驱动程序需要首相向dmaengine系统申请DMA通道
申请DMA通道的函数：dma_request_slave_channel();
struct dma_chan *dma_request_slave_channel(struct device *dev, const char *name);

struct dma_chan *__dma_request_channel(const dma_cap_mask_t *mask, dma_filter_fn fn, void *fn_param);
1
2
3
释放申请的通道
void dma_release_chammel(struct dma_chan* chan);
1
例程：利用dmaengine初始化并发起一次DMA操作
static void xxx_dma_fini_callback(void *data)
{
    struct completion *dma_complete = data;
    complete(dma_complete);
}

issue_xxx_dma(...)
{
    rx_desc = dmaengine_prep_slave_single(xxx->rx_chan,xxx->dst_start, t->len, DMA_DEV_TO_MEN, DMA_PREP_INTERRUPT | DMA_CTRL_ACK);
    rx_desc->callback = xxx_dma_fini_callback;
    rx_desc-。callback-param = &xxx->rx_done;

    dmaengine_submit(rx_desc);
    dma_async_issue_pending(xxx->rx_chan);
}

《Linux4.0设备驱动开发详解》笔记--第十二章：Linux设备驱动的软件架构思想

《Linux4.0设备驱动开发详解》笔记--第十三章：Linux块设备驱动

《Linux4.0设备驱动开发详解》笔记--第十四章：Linux网络设备驱动

《Linux4.0设备驱动开发详解》笔记--第十五章：Linux I2C核心、总线与设备驱动

2016年05月20日 13:49:38 zcj仲从建 阅读数 4701
 版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/z1106609486/article/details/51461127
15.1 Linux I2C体系结构

I2C核心 
I2C核心提供了I2C总线驱动和设备驱动的注册、注销的方法，I2C通信（Algorithm）方法上层的与具体适配器无关代码以及探测设备、检测设备地址的上层代码等
I2C总线驱动 
是对I2C体系结构中适配器端的实现，适配器可由CPU控制，甚至可以直接集成在CPU内部
总线驱动包含I2C适配器数据结构i2c_adapter、I2C适配器的Algorithm数据结构i2c_algorithm和控制I2C适配器产生通信信号的函数
I2C设备驱动 
它是对I2C硬件体系结构中设备端的实现，设备一般挂接在受CPU控制的I2C适配器上，通过I2C适配器与CPU通信
I2C驱动主要包含数据结构i2c_driver和i2c_client，需要根据的设备实现其中的成员函数
所有的I2C设备都在sysfs文件系统中显示，存在/sys/bus/i2c目录下，以适配器地址和芯片地址的形式列出
/drivers/i2c/下的文件介绍 
i2c-core.c：实现了I2C核心的功能以及/proc/bus/i2c*接口
i2c-dev.c：实现I2C适配器设备文件的功能，每一个适配器被分配一个设备 
设配器的主设备号位89，次设备号位：0-255
i2c_dev.c并不是根据具体的设备而设计的，只是提供了同用的read()、write()和ioctl()等接口，应用层可以通过这些接口访问挂接在适配器上的I2C设备的存储空间或寄存器，并控制I2C设备的工作方式
busses文件夹：包含一些I2C主机控制器驱动，如i2c_omap.c、i2c_s3c2440c.等
algos文件夹：实现了一些I2C总线适配器的通信方法
i2c_adapter、i2c_algorithm、i2c_driver和i2c_client数据结构的作用及其之间的关系 
i2c_adapter与i2c_algorithm 
i2c_adapter对应于物理上的一个适配器，而i2c_algorithm对应于一套通信方法
一个i2c_adapter需要i2c_algorithm提供的通信函数来控制适配器产生特定的访问周期
i2c_algorithm中的关键函数master_xfer()用于产生I2C访问周期需要的信号，以i2c_msg（即I2C消息）为单位
i2c_driver与i2c_client 
i2c_driver对应于一套驱动方法，struct i2c_device_id形式的id_table是该驱动所支持的I2C设备的ID表
i2c_client对应于真实的物理设备，每个I2C设备都需一个i2c_client来描述
一个i2c_driver支持多个同类型的i2c_client
i2c_client的信息通常在BSP的板文件中通过i2c_board_info填充，包括设备的ID号、地址、中断号等信息
在I2C总线驱动i2c_bus_type的match()函数i2c_device_match()中，会调用i2c_match_id()函数匹配在板文件中定义的ID和i2c_driver所支持的ID表
i2c_adapter与i2c_client 
其关系与I2C设备体系中适配器与设备的关系一致，即i2c_client依附于i2c_driver
一个i2c_driver可以被多个i2c_client依附，i2c_driver中包含有依附它的i2c_client的链表
15.2 I2C核心

增加、删除i2c_adapter
int i2c_add_adapter(struct i2c_adapter *adap);
int i2c_del_adapter(struct i2c_adapter *adap);
1
2
增加、删除i2c_driver
int i2c_register_driver(struct module *owner, struct i2c_driver *driver);
int i2c_del_driver(struct i2c_driver *driver);
inline int i2c_add_driver(struct i2c_driver *driver);
1
2
3
4
i2c_client依附/脱离
int i2c_attach_client(struct i2c_client *client);
int i2c_detach_client(struct i2c_client *client);
1
2
当一个具体的client被侦测到并被关联的时候，设备和sysfs文件将被注册。相反地，在client被取消关联的时候，sysfs文件和设备也被注销 
代码清单15.6 I2C核心client attach/detach函数

1  int i2c_attach_client(struct i2c_client *client)
2  {
3    ...
4   device_register(&client->dev);
5   device_create_file(&client->dev, &dev_attr_client_name);
6   
7   return 0;
8  }
9  
10 int i2c_detach_client(struct i2c_client *client)
11 {
12   ...
13  device_remove_file(&client->dev, &dev_attr_client_name);
14  device_unregister(&client->dev);
15   ...
16 }
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
I2C传输、发送和接收
int i2c_transfer(struct i2c_adapter * adap, struct i2c_msg *msgs, int num);
int i2c_master_send(struct i2c_client *client,const char *buf ,int count);
int i2c_master_recv(struct i2c_client *client, char *buf ,int count);
1
2
3
4
i2c_transfer ()函数用于进行I2C适配器和I2C设备之间的一组消息交互，i2c_master_send()函数和i2c_master_recv()函数内部会 调用i2c_transfer()函数分别完成一条写消息和一条读消 
例如：

代码清单15.7 I2C核心i2c_master_send函数
1  int i2c_master_send(struct i2c_client *client,const char *buf ,int count)
2  {
3   int ret;
4   struct i2c_adapter *adap=client->adapter;
5   struct i2c_msg msg;
6    /*构造一个写消息*/
7   msg.addr = client->addr;
8   msg.flags = client->flags & I2C_M_TEN;
9   msg.len = count;
10  msg.buf = (char *)buf;
11  /*传输消息*/
12  ret = i2c_transfer(adap, &msg, 1);
13 
14  return (ret == 1) ? count : ret;
15 }
代码清单15.8 I2C核心i 2c_master_recv函数
1  int i2c_master_recv(struct i2c_client *client, char *buf ,int count)
2  {
3   struct i2c_adapter *adap=client->adapter;
4   struct i2c_msg msg;
5   int ret;
6   /*构造一个读消息*/
7   msg.addr = client->addr;
8   msg.flags = client->flags & I2C_M_TEN;
9   msg.flags |= I2C_M_RD;
10  msg.len = count;
11  msg.buf = buf;
12  /*传输消息*/
13  ret = i2c_transfer(adap, &msg, 1);
14 
15  /* 成功（1条消息被处理）， 返回读的字节数 */
16  return (ret == 1) ? count : ret;
17 }
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
i2c_transfer()函数本身不具备驱动适配器物理硬件完成消息交互的能力，它只是寻找到i2c_adapter对应的i2c_algorithm，并使用i2c_algorithm的master_xfer()函数真正驱动硬件流程，如下例程：

I2C核心i 2c_transfer函数
1  int i2c_transfer(struct i2c_adapter * adap, struct i2c_msg *msgs, int num)
2  {
3   int ret;
4  
5   if (adap->algo->master_xfer) {
6    down(&adap->bus_lock);
7    ret = adap->algo->master_xfer(adap,msgs,num); /* 消息传输 */
8    up(&adap->bus_lock);
9    return ret;
10  } else {
11   dev_dbg(&adap->dev, "I2C level transfers not supported\n");
12   return -ENOSYS;
13  }
14 }
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
15.3 Linux I2C总线驱动

15.3.1 I2C适配器驱动加载与卸载

I2C总线驱动模块的加载函数要完成两个工作： 
初始化I2C适配器所使用的硬件资源，申请I/O地址、中断号等。
通过i2c_add_adapter()添加i2c_adapter的数据结构，当然这个i2c_adapter数据结构的成员已经被xxx适配器的相应函数指针所初始化。
I2C总线驱动模块的卸载函数要完成的工作与加载函数的相反： 
释放I2C适配器所使用的硬件资源，释放I/O地址、中断号等。
通过i2c_del_adapter()删除i2c_adapter的数据结构。
代码清单给出了I2C适配器驱动模块加载和卸载函数的模板。
I2C总线驱动模块加载和卸载函数模板
1  static int __init i2c_adapter_xxx_init(void)
2  {
3    xxx_adpater_hw_init();
4    i2c_add_adapter(&xxx_adapter);
5  }
6  
7  static void __exit i2c_adapter_xxx_exit(void)
8  {
9    xxx_adpater_hw_free();
10   i2c_del_adapter(&xxx_adapter);
11 }
1
2
3
4
5
6
7
8
9
10
11
12
 - 上述代码中xxx_adpater_hw_init()和xxx_adpater_hw_free()函数的实现都与具体的CPU和I2C设备硬件直接相关。
1
15.3.2 I2C总线通信方法

我们需要为特定的I2C适配器实现其通信方法，主要实现i2c_algorithm的master_xfer()函数和functionality()函数。 
functionality()函数用于返回algorithm所支持的通信协议，如I2C_FUNC_I2C、I2C_FUNC_10BIT_ADDR、SMBUS_READ_BYTE、I2C_FUNC_SMBUS_WRITE_BYTE等。
master_xfer()函数在I2C适配器上完成传递给它的i2c_msg数组中的每个I2C消息
代码给出了xxx设备的master_xfer()函数模板。
I2C总线驱动master_xfer函数模板
1  static int i2c_adapter_xxx_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,
2    int num)
3  {
4    ...
5    for (i = 0; i < num; i++)
6    {
7      i2c_adapter_xxx_start(); /*产生开始位*/
8      /*是读消息*/
9      if (msgs[i]->flags &I2C_M_RD)
10     {
11       i2c_adapter_xxx_setaddr((msg->addr << 1) | 1); /*发送从设备读地址*/
12       i2c_adapter_xxx_wait_ack(); /*获得从设备的ack*/
13       i2c_adapter_xxx_readbytes(msgs[i]->buf, msgs[i]->len); /*读取msgs[i]
14         ->len长的数据到msgs[i]->buf*/
15     }
16     else
17      /*是写消息*/
18     {
19       i2c_adapter_xxx_setaddr(msg->addr << 1); /*发送从设备写地址*/
20       i2c_adapter_xxx_wait_ack(); /*获得从设备的ack*/
21       i2c_adapter_xxx_writebytes(msgs[i]->buf, msgs[i]->len); /*读取msgs[i]
22         ->len长的数据到msgs[i]->buf*/
23     }
24   }
25   i2c_adapter_xxx_stop(); /*产生停止位*/
26 }
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
 - 上述代码实际上给出了一个master_xfer()函数处理I2C消息数组的流程，对于数组中的每个消息，判断消息类型，若为读消息，则赋从设备地址为    (msg->addr << 1) | 1，否则为msg->addr << 1。对每个消息产生1个开始位，紧接着传送从设备地址，然后开始数据的发送或接收，对最后的消息还需产生1个停止位。图15.3描述了整个master_xfer()完成的时序。
1
多数I2C总线驱动会定义一个xxx_i2c结构体，作为i2c_adapter的algo_data（类似“私有数据”） 
xxx_i2c结构体包含I2C消息数组指针、数组索引及I2C适配器algorithm访问控制用的自旋锁、等待队列等
master_xfer()函数完成消息数组中消息的处理也可通过对xxx_i2c结构体相关成员的访问来控制。
1  struct xxx_i2c 
2  {
3   spinlock_t  lock;
4   wait_queue_head_t wait;  
5   struct i2c_msg  *msg;
6   unsigned int  msg_num;
7   unsigned int  msg_idx;
8   unsigned int  msg_ptr;
9   ...
10  struct i2c_adapter adap;
11 };
1
2
3
4
5
6
7
8
9
10
11
15.4 linux I2C设备驱动

15.4.1 Linux I2C设备驱动模块加载与卸载

I2C设备驱动模块加载函数通用的方法是在I2C设备驱动模块加载函数中完成两件事： 
通过register_chrdev()函数将I2C设备注册为一个字符设备。
通过I2C核心的i2c_add_driver()函数添加i2c_driver。
在模块卸载函数中需要做相反的两件事： 
通过I2C核心的i2c_del_driver()函数删除i2c_driver。
通过unregister_chrdev()函数注销字符设备。
1  static int __init yyy_init(void)
2  {
3    int res;
4    /*注册字符设备*/
5    res = register_chrdev(YYY_MAJOR, "yyy", &yyy_fops); //老内核接口
6    if (res)
7      goto out;
8    /*添加i2c_driver*/
9    res = i2c_add_driver(&yyy_driver);
10   if (res)
11     goto out_unreg_class;
12   return 0;
13 
14   out_unreg_chrdev: unregister_chrdev(I2C_MAJOR, "i2c");
15   out: printk(KERN_ERR "%s: Driver Initialisation failed\n", __FILE__);
16   return res;
17 }
18 
19 static void __exit yyy_exit(void)
20 {
21   i2c_del_driver(&i2cdev_driver);
22   unregister_chrdev(YYY_MAJOR, "yyy");
23 }
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
15.4.2 Linux I2C设备驱动的数据传输

I2C设备上的读写数据的时序且数据通常通过i2c_msg消息数组进行组织，最后通过i2c_transfer函数完成
1  static int yyy_cmd1(struct i2c_client *client, struct rtc_time *dt)
2  {
3   struct i2c_msg msg[2];
4   /*第一条消息是写消息*/
5   msg[0].addr = client->addr;
6   msg[0].flags = 0;
7   msg[0].len = 1;
8   msg[0].buf = &offs;
9   /*第二条消息是读消息*/
10  msg[1].addr = client->addr;
11  msg[1].flags = I2C_M_RD;
12  msg[1].len = sizeof(buf);
13  msg[1].buf = &buf[0];
14  
15  i2c_transfer(client->adapter, msg, 2);
16   ...
17 }
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
15.4.3 Linux i2c-dev.c文件分析

i2c-dev.c文件可以被看作一个I2C设 备驱动，它实现的一个i2c_client是虚拟的、临时的，随着设备文件的打开而产生，并随设备文件的关闭而撤销，并没有被添加到i2c_adapter的clients链表中。

i2c-dev.c针对每个I2C适配器生成一个主设备为89的设备文件，实现了i2c_driver的成员函数以及文件操作接口

i2c-dev.c的主体是“i2c_driver成员函数 + 字符设备驱动”。

i2c-dev.c中提供i2cdev_read()、i2cdev_write()函数来对应用户空间要使用的read()和 write()文件操作接口，这两个函数分别调用I2C核心的i2c_master_recv()和i2c_master_send()函数来构造1条 I2C消息并引发适配器algorithm通信函数的调用，完成消息的传输

i2c-dev.c中i2cdev_read()和i2cdev_write()函数不具备太强的通用性，没有太大的实用价值，只能适用于非RepStart模式的情况。

对于2条以上消息组成的读写，在用户空间需要组织i2c_msg消息数组并调用I2C_RDWR IOCTL命令。

代码给出了i2cdev_ioctl()函数的框架，其中详细列出了I2C_RDWR命令的处理过程。

 i2c-dev.c中的i2cdev_ioctl函数
1  static int i2cdev_ioctl(struct inode *inode, struct file *file,
2    unsigned int cmd, unsigned long arg)
3  {
4   struct i2c_client *client = (struct i2c_client *)file->private_data;
5    ...  
6   switch ( cmd ) {
7   case I2C_SLAVE:
8   case I2C_SLAVE_FORCE:
9    ...   /*设置从设备地址*/
10  case I2C_TENBIT:
11   ...
12  case I2C_PEC:
13   ...
14  case I2C_FUNCS:
15   ...  
16  case I2C_RDWR:
17   if (copy_from_user(&rdwr_arg, 
18        (struct i2c_rdwr_ioctl_data __user *)arg, 
19        sizeof(rdwr_arg)))
20    return -EFAULT;
21   /* 一次传入的消息太多 */
22   if (rdwr_arg.nmsgs > I2C_RDRW_IOCTL_MAX_MSGS)
23    return -EINVAL;
24   /*获得用户空间传入的消息数组
25   rdwr_pa = (struct i2c_msg *)
26    kmalloc(rdwr_arg.nmsgs * sizeof(struct i2c_msg), 
27    GFP_KERNEL);    
28   if (rdwr_pa == NULL) return -ENOMEM;
29   if (copy_from_user(rdwr_pa, rdwr_arg.msgs,
30        rdwr_arg.nmsgs * sizeof(struct i2c_msg))) {
31    kfree(rdwr_pa);
32    return -EFAULT;
33   }
34   data_ptrs = kmalloc(rdwr_arg.nmsgs * sizeof(u8 __user *), GFP_KERNEL);
35   if (data_ptrs == NULL) {
36    kfree(rdwr_pa);
37    return -ENOMEM;
38   }
39   res = 0;
40   for( i=0; i41    /* 限制消息的长度 */
42    if (rdwr_pa[i].len > 8192) {
43     res = -EINVAL;
44     break;
45    }
46    data_ptrs[i] = (u8 __user *)rdwr_pa[i].buf;
47    rdwr_pa[i].buf = kmalloc(rdwr_pa[i].len, GFP_KERNEL);
48    if(rdwr_pa[i].buf == NULL) {
49     res = -ENOMEM;
50     break;
51    }
52    if(copy_from_user(rdwr_pa[i].buf,
53     data_ptrs[i],
54     rdwr_pa[i].len)) {
55      ++i; /* Needs to be kfreed too */
56      res = -EFAULT;
57     break;
58    }
59   }
60   if (res < 0) {
61    int j;
62    for (j = 0; j < i; ++j)
63     kfree(rdwr_pa[j].buf);
64    kfree(data_ptrs);
65    kfree(rdwr_pa);
66    return res;
67   }
68    /*把这些消息交给通信方法去处理*/
69   res = i2c_transfer(client->adapter,
70    rdwr_pa,
71    rdwr_arg.nmsgs);
72   while(i-- > 0) {   /*如果是读消息，把值拷贝到用户空间*/
73    if( res>=0 && (rdwr_pa[i].flags & I2C_M_RD)) {
74     if(copy_to_user(
75      data_ptrs[i],
76      rdwr_pa[i].buf,
77      rdwr_pa[i].len)) {
78      res = -EFAULT;
79     }
80    }
81    kfree(rdwr_pa[i].buf);
82   }
83   kfree(data_ptrs);
84   kfree(rdwr_pa);
85   return res;
86  case I2C_SMBUS:
87   ... 
88  default:
89   return i2c_control(client,cmd,arg);
90  }
91  return 0;
92 }
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
 - 常用的IOCTL包括I2C_SLAVE（设置从设备地址）、I2C_RETRIES（没有收到设备ACK情况下的重试次数，缺省为1）、I2C_TIMEOU（超时）以及I2C_RDWR。
1
下面两个代码分别演示了直接通过read()、write()接口和O_RDWR IOCTL读写I2C设备的例子。

代码清单15.23 直接通过read()/write()读写I2C设备
1  #include 
2  #include 
3  #include 
4  #include 
5  #include 
6  #include 
7  #include 
8  
9  #define I2C_RETRIES     0x0701
10 #define I2C_TIMEOUT     0x0702
11 #define I2C_SLAVE       0x0703
12 
13 int main(int argc, char **argv)
14 {
15   unsigned int fd;
16   unsigned short mem_addr;
17   unsigned short size;
18   unsigned short idx;
19   #define BUFF_SIZE    32
20   char buf[BUFF_SIZE];
21   char cswap;
22   union
23   {
24     unsigned short addr;
25     char bytes[2];
26   } tmp;
27 
28   if (argc < 3)
29   {
30     printf("Use:\n%s /dev/i2c-x mem_addr size\n", argv[0]);
31     return 0;
32   }
33   sscanf(argv[2], "%d", &mem_addr);
34   sscanf(argv[3], "%d", &size);
35 
36   if (size > BUFF_SIZE)
37     size = BUFF_SIZE;
38 
39   fd = open(argv[1], O_RDWR);
40 
41   if (!fd)
42   {
43     printf("Error on opening the device file\n");
44     return 0;
45   }
46 
47   ioctl(fd, I2C_SLAVE, 0x50); /* 设置eeprom地址 */
48   ioctl(fd, I2C_TIMEOUT, 1); /* 设置超时 */
49   ioctl(fd, I2C_RETRIES, 1); /* 设置重试次数 */
50 
51   for (idx = 0; idx < size; ++idx, ++mem_addr)
52   {
53     tmp.addr = mem_addr;
54     cswap = tmp.bytes[0];
55     tmp.bytes[0] = tmp.bytes[1];
56     tmp.bytes[1] = cswap;
57     write(fd, &tmp.addr, 2);
58     read(fd, &buf[idx], 1);
59   }
60   buf[size] = 0;
61   close(fd);
62   printf("Read %d char: %s\n", size, buf);
63   return 0;
64 }
代码清单15.24 通过O_RDWR IOCTL读写I2C设备
1  #include 
2  #include 
3  #include 
4  #include 
5  #include 
6  #include 
7  #include 
8  #include 
9  #include 
10 #include 
11 
12 #define MAX_I2C_MSG         2
13 
14 #define I2C_RETRIES     0x0701
15 #define I2C_TIMEOUT     0x0702
16 #define I2C_RDWR        0x0707
17 
18 struct i2c_msg
19 {
20   __u16 addr; /* 从地址 */
21   __u16 flags;
22   #define I2C_M_RD        0x01
23   __u8 *buf; /* 消息数据指针 */
24 };
25 struct i2c_rdwr_ioctl_data
26 {
27   struct i2c_msg *msgs; /* i2c_msg[]指针 */
28   int nmsgs; /* i2c_msg数量 */
29 };
30 
31 int main(int argc, char **argv)
32 {
33   struct i2c_rdwr_ioctl_data work_queue;
34   unsigned int idx;
35   unsigned int fd;
36   unsigned short start_address;
37   int ret;
38 
39   if (argc < 4)
40   {
41     printf("Usage:\n%s /dev/i2c-x start_addr\n", argv[0]);
42     return 0;
43   }
44 
45   fd = open(argv[1], O_RDWR);
46 
47   if (!fd)
48   {
49     printf("Error on opening the device file\n");
50     return 0;
51   }
52   sscanf(argv[2], "%x", &start_address);
53   work_queue.nmsgs = MAX_I2C_MSG; /* 消息数量 */
54 
55   work_queue.msgs = (struct i2c_msg*)malloc(work_queue.nmsgs *sizeof(struct
56     i2c_msg));
57   if (!work_queue.msgs)
58   {
59     printf("Memory alloc error\n");
60     close(fd);
61     return 0;
62   }
63 
64   for (idx = 0; idx < work_queue.nmsgs; ++idx)
65   {
66     (work_queue.msgs[idx]).len = 0;
67     (work_queue.msgs[idx]).addr = start_address + idx;
68     (work_queue.msgs[idx]).buf = NULL;
69   }
70 
71   ioctl(fd, I2C_TIMEOUT, 2); /* 设置超时 */
72   ioctl(fd, I2C_RETRIES, 1); /* 设置重试次数 */
73 
74   ret = ioctl(fd, I2C_RDWR, (unsigned long) &work_queue);
75 
76   if (ret < 0)
77   {
78     printf("Error during I2C_RDWR ioctl with error code: %d\n", ret);
79   }
80 
81   close(fd);
82   return ;
83 }

《Linux4.0设备驱动开发详解》笔记--第十六章：USB主机、设备与Gadget驱动

《Linux4.0设备驱动开发详解》笔记--第十七章：I2C、SPI、USB驱动架构类比

《Linux4.0设备驱动开发详解》笔记--第十八章：ARM Linux设备树

2016年05月21日 12:52:36 zcj仲从建 阅读数 2552
版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/z1106609486/article/details/51469942
18.1 ARM设备树简介

设备舒适一种描述印鉴的数据结构，它起源于OpenFirmware（OF） 
采用设备树前后对比： 
采用设备树之前：ARM架构的板极硬件细节过多的被硬编码在arch/arm/plat-xxx和arch/arm/mach-xxx中
采用设备树之后：许多硬件细节可以直接通过它传递给Linux，而不再需要在讷河中进行大量的冗余编码
设备树的组成：由一系列被命名的节点（Node）和属性（Property）组成 
节点本身有包含子节点
属性：成对出现的名称和值
设备树中可描述的信息包括： 
CPU的数量和类别
内存基地址和大小
总线和桥
外设链接
中断控制器和中断使用情况
GPIO控制器和GPIO使用情况
时钟控制器核实中使用情况
通俗描述： 
它基本上就是画一颗电路板上CPU、总线、设备组成的树
bootloader会将这棵树传递给内核
内核可以识别这棵树，并根据他站开出Linux内核中的platform_device、i2c_client、spi_device等设备
这些设备用到的内存、IRQ等资源，也被传递给了内核，内核会将这些资源绑定给展开的相应的设备
18.2 设备树的组成和结构

整个设备数牵涉买你比较广，既增加了新的用于描述设备硬件信息的文件格式，又增加了编译这个文本的工具，同时bootloader也需要支持将编译后的设备数传递给Linux内核
18.2.1 DTS、DTC和DTB等

18.2.1.1 DTS

DTS：文件.dts是一种ASCII文本格式的设备树描述，人性化适合阅读 
.dts的基本元素为节点和属性
ARM Linux中，一个.dts文件对应一个ARM的设备，一般放置在内核的arch/arm/boot/dts目录中
DTS不是ARM独有的：在arch/powerpc/boot/dts、arch/openrisc/boot/dts等目录中，也有大量的.dts文件
SOC公用的部分或多个设备共同的部分一般提炼为.dtsi，类似C的头文件，其他设备对应的.dts就包含.dtsi 
和C语言的头文件类似，.dtsi也可以包括其他的.dtsi，譬如几乎所有的ARM SOC的.dtsi都引用了skeleton.dtsi
如下：设备数的模板 
他基本表征了一个设备树源文件的结构 
1个root节点”/”;
root节点下面含一系列子节点，如代码中的child-node1和child-node2
节点node1和下又含有一系列子节点，如本例中的child-node1和child-node2
各个节点都有一系列属性 
这些属性可能为空，如an-empty-property
可能为字符串，如a-string-property
可能为字符串树组，如a-string-list-property
可能为Cells（由u32整数组成），如second-child-property
可能为二进制数，如a-byte-data-property
/ {
    nodel {
        a-string-property = "A string";
        a-string-list-property = "first string", "second string"
        a-byte-data-property = {0x01 0x23 0x34 0x56};
        child-node {
            first-child-property;
            second-child-property = <1>
            a-string-property = "Hello, world"
        };
        child-node2 {
        };
    };
   node2 {
        an-enpty-property;
        a-cell-property = <1 2 3 4>; /* each munber (cell) is a uint32 */
        child-node1 {
        };
    };
};
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
简单的设备数文件实例 
假设此machine的配置如下： 
1个双核ARM Cortex-A9 32位处理器；
ARM的local bus上的内存映射区域分布了 
2个串口（分别位于0x101F1000 和 0x101F2000）
GPIO控制器（位于0x101F3000）
SPI控制器（位于0x10170000）
中断控制器（位于0x10140000）
一个external bus桥，该桥上又连接了 
SMC SMC91111 Ethernet（位于0x10100000）
64MB NOR Flash（位于0x30000000）
I2C控制器（位于0x10160000），该I2C控制器所对应的I2C总线上又连接了 
Maxim DS1338实时钟（I2C地址为0x58）
其对应的.dts文件如下： 
从代码可知，external-bus是根节点的子节点，I2C又是external-bus的子节点，RTC有进一步是I2C的子节点
/ {
    compatible = "acme,coyotes-revenge";
    #address-cells = <1>;
    #size-cells = <1>;
    interrupt-parent = <&intc>;

    cpus {
        #address-cells = <1>;
        #size-cells = <0>;
        cpu@0 {
            compatible = "arm,cortex-a9";
            reg = <0>;
        };
        cpu@1 {
            compatible = "arm,cortex-a9";
            reg = <1>;
        };
    };

    serial@101f0000 {
        compatible = "arm,pl011";
        reg = <0x101f0000 0x1000 >;
        interrupts = < 1 0 >;
    };

    serial@101f2000 {
        compatible = "arm,pl011";
        reg = <0x101f2000 0x1000 >;
        interrupts = < 2 0 >;
    };

    gpio@101f3000 {
        compatible = "arm,pl061";
        reg = <0x101f3000 0x1000
               0x101f4000 0x0010>;
        interrupts = < 3 0 >;
    };

    intc: interrupt-controller@10140000 {
        compatible = "arm,pl190";
        reg = <0x10140000 0x1000 >;
        interrupt-controller;
        #interrupt-cells = <2>;
    };

    spi@10115000 {
        compatible = "arm,pl022";
        reg = <0x10115000 0x1000 >;
        interrupts = < 4 0 >;
    };

    external-bus {
        #address-cells = <2>
        #size-cells = <1>;
        ranges = <0 0  0x10100000   0x10000     // Chipselect 1, Ethernet
                  1 0  0x10160000   0x10000     // Chipselect 2, i2c controller
                  2 0  0x30000000   0x1000000>; // Chipselect 3, NOR Flash

        ethernet@0,0 {
            compatible = "smc,smc91c111";
            reg = <0 0 0x1000>;
            interrupts = < 5 2 >;
        };

        i2c@1,0 {
            compatible = "acme,a1234-i2c-bus";
            #address-cells = <1>;
            #size-cells = <0>;
            reg = <1 0 0x1000>;
            interrupts = < 6 2 >;
            rtc@58 {
                compatible = "maxim,ds1338";
                reg = <58>;
                interrupts = < 7 3 >;
            };
        };

        flash@2,0 {
            compatible = "samsung,k8f1315ebm", "cfi-flash";
            reg = <2 0 0x4000000>;
        };
    };
};
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
18.2.1.2 DTC(Device Tree Compiler)

DTC是将.dts编译为.dtb的工具 
DTC的源代码位于内核的scripts/dtc目录中
在Linux内核使能了Device Tree的情况下，编译内核的时候主机工具dtc会被编译出来，对应scripts/dtc/Makefile中的“hostprogs-y := dtc”这一hostprogs编译target
Ubuntu中单独安装DTC：sudo apt-get install device-tree-compiler
在Linux内核的arch/arm/boot/dts/Makefile中，描述了当某种SOC被选中后，哪些.dtb文件会被编译出来 
如与VEXPRESS对应的.dtb如下： 
在Linux下可以单独编译设备树文件，当在Linux内核下运行make dtbs时，若之前选择了ARCH_VEXPRESS，上述.dtb都会有对应的.dts编译出来，因为arch/arm/Makefile中包含有一个.dtbs编译目标项目
dtb-$(CONFIG_ARCH_VEXPRESS) += vexpress-v2p-ca5s.dtb \
        vexpress-v2p-ca9.dtb \
        vexpress-v2p-ca15-tc1.dtb \
        vexpress-v2p-ca15_a7.dtb \
        xenvm-4.2.dtb
1
2
3
4
5
18.2.1.3 DTB(Device Tree Blob)

文件.dtb是.dts被DTC编译后的二进制格式的设备树描述，可由Linux内核解析，UBOOT也可以识别 
使用.dtb两种方式： 
在制作NAND、SD启动映像时会留有一小片区域给.dtb文件单独存放，bootloader在引导内核时会先读取该.dtb到内存
将.dtb直接和zImage绑定在一起做成一个映像文件，此时内核编译时需要使能CONFIG_ARM_APPENDED_DTB选项
18.2.1.4 绑定（Bingding）

设备树绑定文档(.txt)：描述对应节点的兼容性、必要的属性和可选的属性 
文档位置：内核的Documentation/devicetree/bindings目录 
其下又分为很多子目录，譬如，Documentation/devicetree/bindings/i2c/i2c-xiic.txt描述了Xilinx的I2C控制器
文档主要内容： 
关于该模块的最基本描述
必需属性（Required Properties）的描述
可选属性（Optional properties）的描述
一个实例
18.2.1.5 Bootloader

使能设备树的bootloader配置 
编译UBOOT的时候在config文件中加入：#define CONFIG_OF_LIBFDT
在UBOOT中，可以从NAND、SD或者TFTP等任意介质中将.dtb读入内存 
例如：假设.dtb放入的内存地址为0x71000000，之后可在UBOOT中运行fdt addr命令设置.dtb的地址 
fdt的其他命令就变得可以使用，如fdt resize、fdt print等
对于ARM来讲，可以通过bootz kernel_addr initrd_address dtb_address的命令来启动内核 
dtb_address作为bootz或者bootm的最后一次参数，第一个参数为内核映像的地址，第二个参数为initrc的地址
UBoot > fdt addr 0x71000000
1
18.2.2 根节点兼容性

Linux内核通过根节点“/”的兼容性即可判断它启动的是什么设备 
组织形式：,
兼容性的包含成员 
首个兼容性的字符串是板子级别的名字
后面一个兼容性是芯片级别的名字
两个字符串兼容性实例如例1： 
代码中各个电路板的共性是兼容于arm，vexpress，尔特性分别兼容于：arm,vexpress,v2p-ca9/ca5s/ca15_a7
多个字符串兼容性实例如例2： 
第一个字符串是板子名字（很特定），第二个是芯片名字（比较特定），第三个是芯片系列的名字（比较通用）
//例1
//板子arch/arm/boot/dts/vexpress-v2p-ca9.dts兼容于"arm,vexpress,v2p-ca9"和“arm,vexpress”
compatible = "arm,vexpress,v2p-ca9", "arm, vexpress"
//板子arch/arm/boot/dts/vexpress-v2p-ca5s.dts兼容性如下：
compatible = "arm,vexpress,v2p-ca5s", "arm, vexpress"
//板子arch/arm/boot/dts/vexpress-v2p-ca15_a7.dts兼容性如下：
compatible = "arm,vexpress,v2p-ca15_a7", "arm, vexpress"

//例2
//arch/arm/boot/dts/exymos4210-origen.dts的兼容性：
compatible = "insignal,origen", "samsung,exynos4210", "samsung,exynos4"
//arch/arm/boot/dts/exymos4210-universal_c210.dts的兼容性：
compatible = "insignal,universal_c210", "samsung,exynos4210", "samsung,exynos4"
1
2
3
4
5
6
7
8
9
10
11
12
13
ARM Linux针对不同的电路板会建立由MACHINE_START和MACHINE_END包围起来的针对这个machine的一系列callback 
ARM Linux3.x引入Device Tree之后，MACHINE_START变更为DT_MACHINE_START 
DT_MACHINE_START中含有一个.dt_compat成员，用于表明相关的machine与.dts中root结点的compatible属性兼容关系
如果Bootloader传递给内核的Device Tree中root结点的compatible属性出现在某machine的.dt_compat表中，相关的machine就与对应的Device Tree匹配，从而引发这一machine的一系列初始化函数被执行。
 static const char * const v2m_dt_match[] __initconst = {
         "arm,vexpress",
         "xen,xenvm",
         NULL,
 };
 DT_MACHINE_START(VEXPRESS_DT, "ARM-Versatile Express")
         .dt_compat      = v2m_dt_match,
         .smp            = smp_ops(vexpress_smp_ops),
         .map_io         = v2m_dt_map_io,
         .init_early     = v2m_dt_init_early,
         .init_irq       = v2m_dt_init_irq,
         .timer          = &v2m_dt_timer,
         .init_machine   = v2m_dt_init,
         .handle_irq     = gic_handle_irq,
         .restart        = vexpress_restart,
 MACHINE_END
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
Linux倡导针对多个SoC、多个电路板的通用DT machine，即一个DT machine的.dt_compat表含多个电路板.dts文件的root结点compatible属性字符串 
如果这么多电路板的初始化序列不一样，可以透过以下API判断具体的电路板是什么 
此API判断目前运行的板子或者SOC的兼容性，它匹配的是设备树根节点下的兼容性
如果一个兼容包含多个字符串，譬如对于前面介绍的根节点兼容compatible = “samsung, universal_c210”, “samsung,exynos4210”,”samsung,exynos4”的情况，如下表达式都成立
int of_machine_is_compatible(const char *compat) 

of_machine_is_compatible("samsung,universal_c210")
of_machine_is_compatible("samsung,exynos4210")
of_machine_is_compatible("samsung,exynos4")
1
2
3
4
5
18.2.3 设备节点兼容性

在.dts文件的每个设备节点中，都有一个兼容性属性，用于驱动和设备的绑定 
兼容属性是一个字符串的列表，形式为”,” 
第一个字符串表征节点代表的确切设备，是个特指
第二个字符串表征可兼容的其他设备，涵盖更广的范围
例如：在vexpress-v2m.dtsi中Flash节点如下 
兼容属性的第2个字符串“cfi-flash”明显比第1个字符串“arm，vexpress-flash”涵盖范围更广
flash@0,00000000 {
compatible = "arm,vexpress-flash","cfi-flash";
reg = <0 0x00000000 0x04000000>
<1 0x00000000 0x04000000>;
bank-width = <4>
};
1
2
3
4
5
6
使用设备树后，驱动需要与.dts中描述的设备节点进行匹配，从而使驱动的probe()函数执行 
对于platform_driver而言，需要添加一个OF匹配表，如前文的.dts文件的“acme,a1234-i2c-bus”兼容I2C控制节点的OF匹配表，代码如下：
对于i2c和spi从设备而言，同样也可以通过of_match_table添加匹配的.dts中的相关节点的兼容属性
i2c和spi外设备驱动和设备树中设备节点的兼容属性还有一种弱势匹配方法——“别名”匹配 
别名就是去掉兼容属性中manufacturer前缀后的部分
//platform设备驱动中的of_match_table
 static const struct of_device_id a1234_i2c_of_match[] = {
         { .compatible = "acme,a1234-i2c-bus ", },
         {},
 };
 MODULE_DEVICE_TABLE(of, a1234_i2c_of_match);

 static struct platform_driver i2c_a1234_driver = {
         .driver = {
                 .name = "a1234-i2c-bus ",
                 .owner = THIS_MODULE,
                 .of_match_table = a1234_i2c_of_match,
         },
         .probe = i2c_a1234_probe,
         .remove = i2c_a1234_remove,
 };
 module_platform_driver(i2c_a1234_driver);

//i2c和spi设备驱动中的of_match_table
 static const struct of_device_id wm8753_of_match[] = {
         { .compatible = "wlf,wm8753", },
         { }
 };
 MODULE_DEVICE_TABLE(of, wm8753_of_match);
 static struct spi_driver wm8753_spi_driver = {
         .driver = {
                 .name   = "wm8753",
                .owner  = THIS_MODULE,
                 .of_match_table = wm8753_of_match,
        },
         .probe          = wm8753_spi_probe,
         .remove         = wm8753_spi_remove,
 };
 static struct i2c_driver wm8753_i2c_driver = {
         .driver = {
                 .name = "wm8753",
                 .owner = THIS_MODULE,
                 .of_match_table = wm8753_of_match,
         },
         .probe =    wm8753_i2c_probe,
         .remove =   wm8753_i2c_remove,
         .id_table = wm8753_i2c_id,
 };

//spi的别名匹配
   static int spi_match_device(struct device *dev, struct device_driver *drv) 
   { 
           const struct spi_device *spi = to_spi_device(dev); 
          const struct spi_driver *sdrv = to_spi_driver(drv); 

           /* Attempt an OF style match */ 
           if (of_driver_match_device(dev, drv)) 
                   return 1; 

          /* Then try ACPI */ 
          if (acpi_driver_match_device(dev, drv)) 
                  return 1; 

          if (sdrv->id_table) 
                  return !!spi_match_id(sdrv->id_table, spi); 

          return strcmp(spi->modalias, drv->name) == 0; 
  } 
  static const struct spi_device_id *spi_match_id(const struct spi_device_id *id,
 const struct spi_device *sdev) 
  { 
          while (id->name[0]) { 
                  if (!strcmp(sdev->modalias, id->name)) 
                          return id; 
                  id++; 
          }
          return NULL; 
  }  
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
当一个驱动支持两个或多个设备的时候，这些不同的.dts文件中设备的兼容属性都会写入驱动OF匹配表 
驱动可以通过bootloader传递给内核设备树中的真正节点的兼容属性以确定究竟是哪一种设备，从而不同设备不同处理
Linux内核通过如下of_device_is_compatible的API来判断具体的设备是什么 
除了上面方法，还可以采用在驱动的of_device_id表中填充.data成员的形式 
例如，arch/arm/mm/cache-12x0.c支持“arm,1210-cache” “arm,p1310-cache” “arm,1220-cache”等多种设备
int of_device_is_compatible(const struct device_node *device, const char *compat);
1
18.2.4 设备节点及label的命名

root结点”/”的cpus子节点下面又包含2个cpu子结点，描述了此machine上的2个CPU，且它们的compatible 属性为”arm,cortex-a9”。

cpus和cpus的2个cpu子结点的命名所遵循的组织形式为：[@] 
<>中的内容是必选项，[]中的则为可选项
name：是一个ASCII字符串，用于描述结点对应的设备类型，如3com Ethernet适配器对应的结点name宜为ethernet，而不是3com509
@unit-address：如果一个结点描述的设备有地址，则应该给出 
设备的unit-address地址也经常在其对应结点的reg属性中给出
多个相同类型设备节点的name可以一样，只要unit-address不同即可，如本例中含有cpu@0、cpu@1以及serial@101f0000与serial@101f2000这样的同名结点
ePAPR标准给出了节点命名的规范，具体可参考
可以给一个设备节点添加label，之后可以通过&label的形式访问这个label，这种引用是通过phandle(pointer handle)进行的

18.2.5 地址编码

可寻址的设备使用如下信息在设备树中编码地址信息 
reg的组织形式为reg =
//代码1
reg
    #address-cells
    #size-cells
1
2
3
4
//代码2
ranges = <0 0  0x10100000   0x10000     // Chipselect 1, Ethernet
              1 0  0x10160000   0x10000     // Chipselect 2, i2c controller
              2 0  0x30000000   0x1000000>; // Chipselect 3, NOR Flash
1
2
3
4
18.2.6 中断连接

对于中断控制器而言，它提供如下属性： 
interrupt-controller – 这个属性为空，中断控制器应该加上此属性表明自己的身份
#interrupt-cells – 与#address-cells 和 #size-cells相似，它表明连接此中断控制器的设备的interrupts属性的cell大小
在整个Device Tree中，与中断相关的属性还包括： 
interrupt-parent – 设备结点透过它来指定它所依附的中断控制器的phandle，当节点没有指定interrupt-parent 时，则从父级节点继承 
对于本例而言，root节点指定了interrupt-parent = <&intc>;其对应于intc:interrupt-controller@10140000，而root节点的子节点并未指定interrupt-parent，因此它们都继承了intc，即位于0x10140000的中断控制器。
interrupts – 用到了中断的设备节点透过它指定中断号、触发方法等，具体这个属性含有多少个cell，由它依附的中断控制器节点的#interrupt-cells属性决定。而具体每个cell又是什么含义，一般由驱动的实现决定，而且也会在Device Tree的binding文档中说明 
譬如，对于ARM GIC中断控制器而言，#interrupt-cells为3，它3个cell的具体含义Documentation/devicetree/bindings/arm/gic.txt就有如下文字说明：
    The 1st cell is the interrupt type; 0 for SPI interrupts, 1 for PPI
    interrupts.

    The 2nd cell contains the interrupt number for the interrupt type.
    SPI interrupts are in the range [0-987].  PPI interrupts are in the
    range [0-15].

    The 3rd cell is the flags, encoded as follows:
          bits[3:0] trigger type and level flags.
                  1 = low-to-high edge triggered
                  2 = high-to-low edge triggered
                  4 = active high level-sensitive
                  8 = active low level-sensitive
          bits[15:8] PPI interrupt cpu mask.  Each bit corresponds to each of
          the 8 possible cpus attached to the GIC.  A bit set to '1' indicated
          the interrupt is wired to that CPU.  Only valid for PPI interrupts.
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
一个设备还可能用到多个中断号 
对于ARM GIC而言，若某设备使用了SPI的168、169号2个中断，而且都是高电平触发，则该设备结点的interrupts属性可定义为：interrupts = <0 168 4>, <0 169 4>;
18.2.7 GPIO、时钟、pinmux连接

除了中断以外，在ARM Linux中clock、GPIO、pinmux都可以透过.dts中的结点和属性进行描述
18.3 Device Tree引发的BSP和驱动变更

有了Device Tree后，大量的板级信息都不再需要，譬如过去经常在arch/arm/plat-xxx和arch/arm/mach-xxx实施的如下事情：

18.3.1. 注册platform_device，绑定resource，即内存、IRQ等板级信息。

通过设备树后，形如代码1中的platform_device代码都不再需要，其中platform_device会由kernel自动展开 
这些resource实际来源于.dts中设备结点的reg、interrupts属性
典型地，大多数总线都与“simple_bus”兼容，而在SoC对应的machine的.init_machine成员函数中，调用of_platform_bus_probe(NULL, xxx_of_bus_ids, NULL);即可自动展开所有的platform_device 
譬如，假设我们有个XXX SoC，则可在arch/arm/mach-xxx/的板文件中透过如下方式展开.dts中的设备结点对应的platform_device：如代码2
//代码1
90 static struct resource xxx_resources[] = {
91         [0] = {
92                 .start  = …,
93                 .end    = …,
94                 .flags  = IORESOURCE_MEM,
95         },
96         [1] = {
97                 .start  = …,
98                 .end    = …,
99                 .flags  = IORESOURCE_IRQ,
100         },
101 };
102
103 static struct platform_device xxx_device = {
104         .name           = "xxx",
105         .id             = -1,
106         .dev            = {
107                                 .platform_data          = &xxx_data,
108         },
109         .resource       = xxx_resources,
110         .num_resources  = ARRAY_SIZE(xxx_resources),
111 };
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
//代码2
18 static struct of_device_id xxx_of_bus_ids[] __initdata = {
19         { .compatible = "simple-bus", },
20         {},
21 };
22
23 void __init xxx_mach_init(void)
24 {
25         of_platform_bus_probe(NULL, xxx_of_bus_ids, NULL);
26 }
32
33 #ifdef CONFIG_ARCH_XXX
38
39 DT_MACHINE_START(XXX_DT, "Generic XXX (Flattened Device Tree)")
41         …
45         .init_machine   = xxx_mach_init,
46         …
49 MACHINE_END
50 #endif
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
18.3.2 注册i2c_board_info，指定IRQ等板级信息。

形如代码1之类的i2c_board_info代码，目前不再需要出现
//代码1
145 static struct i2c_board_info __initdata afeb9260_i2c_devices[] = {
146         {
147                 I2C_BOARD_INFO("tlv320aic23", 0x1a),
148         }, {
149                 I2C_BOARD_INFO("fm3130", 0x68),
150         }, {
151                 I2C_BOARD_INFO("24c64", 0x50),
152         },
153 };
1
2
3
4
5
6
7
8
9
10
现在只需要把tlv320aic23、fm3130、24c64这些设备结点填充作为相应的I2C controller结点的子结点即可，类似于前面的代码2 
Device Tree中的I2C client会透过I2C host驱动的probe()函数中调用of_i2c_register_devices(&i2c_dev->adapter);被自动展开。
      i2c@1,0 {
            compatible = "acme,a1234-i2c-bus";
            …
            rtc@58 {
                compatible = "maxim,ds1338";
                reg = <58>;
                interrupts = < 7 3 >;
            };
        };
1
2
3
4
5
6
7
8
9
18.3.3 注册spi_board_info，指定IRQ等板级信息。

如下的spi_board_info代码，目前不再需要出现
79 static struct spi_board_info afeb9260_spi_devices[] = {
80         {       /* DataFlash chip */
81                 .modalias       = "mtd_dataflash",
82                 .chip_select    = 1,
83                 .max_speed_hz   = 15 * 1000 * 1000,
84                 .bus_num        = 0,
85         },
86 };
1
2
3
4
5
6
7
8
与I2C类似，现在只需要把mtd_dataflash之类的结点，作为SPI控制器的子结点即可，SPI host驱动的probe函数透过spi_register_master()注册master的时候，会自动展开依附于它的slave。
18.3.4 多个针对不同电路板的machine，以及相关的callback。

过去，ARM Linux针对不同的电路板会建立由MACHINE_START和MACHINE_END包围起来的针对这个machine的一系列callback，譬如： 
[cpp] view plain copy 
373 MACHINE_START(VEXPRESS, “ARM-Versatile Express”) 
374 .atag_offset = 0x100, 
375 .smp = smp_ops(vexpress_smp_ops), 
376 .map_io = v2m_map_io, 
377 .init_early = v2m_init_early, 
378 .init_irq = v2m_init_irq, 
379 .timer = &v2m_timer, 
380 .handle_irq = gic_handle_irq, 
381 .init_machine = v2m_init, 
382 .restart = vexpress_restart, 
383 MACHINE_END
Device Tree之后，MACHINE_START变更为DT_MACHINE_START
18.3.5 设备与驱动的匹配方式

在上面介绍过
18.3.6 设备平台数据属性化

18.4 常用的OF API

在Linux的BSP和驱动代码中，还经常会使用到Linux中一组Device Tree的API,这些API通常被冠以of_前缀，它们的实现代码位于内核的drivers/of目录。
18.4.1 寻找节点

根据compatible属性，获得设备结点 
遍历Device Tree中所有的设备结点，看看哪个结点的类型、compatible属性与本函数的输入参数匹配
大多数情况下，from、type为NULL。
struct device_node *of_find_compatible_node(struct device_node *from, const char *type, const char *compatible);
1
18.4.2 读取属性

int of_property_read_u8_array(const struct device_node *np, const char *propname, u8 *out_values, size_t sz);
int of_property_read_u16_array(const struct device_node *np, const char *propname, u16 *out_values, size_t sz);
int of_property_read_u32_array(const struct device_node *np, const char *propname, u32 *out_values, size_t sz);
int of_property_read_u64(const struct device_node *np, const char *propname, u64 *out_value);
1
2
3
4
读取设备结点np的属性名为propname，类型为8、16、32、64位整型数组的属性 
对于32位处理器来讲，最常用的是of_property_read_u32_array() 
如在arch/arm/mm/cache-l2x0.c中，透过如下语句读取L2 cache的”arm,data-latency”属性：
534         of_property_read_u32_array(np, "arm,data-latency",
535                                    data, ARRAY_SIZE(data));
1
2
在arch/arm/boot/dts/vexpress-v2p-ca9.dts中，含有”arm,data-latency”属性的L2 cache结点如下：
137         L2: cache-controller@1e00a000 {
138                 compatible = "arm,pl310-cache";
139                 reg = <0x1e00a000 0x1000>;
140                 interrupts = <0 43 4>;
141                 cache-level = <2>;
142                 arm,data-latency = <1 1 1>;
143                 arm,tag-latency = <1 1 1>;
144         }
1
2
3
4
5
6
7
8
有些情况下，整形属性的长度可能为1，于是内核为了方便调用者，又在上述API的基础上封装出了更加简单的读单一整形属性的API，它们为int of_property_read_u8()、of_property_read_u16()等，实现于include/linux/of.h：

513 static inline int of_property_read_u8(const struct device_node *np,
514                                        const char *propname,
515                                        u8 *out_value)
516 {
517         return of_property_read_u8_array(np, propname, out_value, 1);
518 }
519
520 static inline int of_property_read_u16(const struct device_node *np,
521                                        const char *propname,
522                                        u16 *out_value)
523 {
524         return of_property_read_u16_array(np, propname, out_value, 1);
525 }
526
527 static inline int of_property_read_u32(const struct device_node *np,
528                                        const char *propname,
529                                        u32 *out_value)
530 {
531         return of_property_read_u32_array(np, propname, out_value, 1);
532 }
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
处整形属性外，字符串属性也比较常用，其对应的API包括：

int of_property_read_string(struct device_node *np, const char
*propname, const char **out_string);
int of_property_read_string_index(struct device_node *np, const char
    *propname, int index, const char **output);
1
2
3
4
前者读取字符串属性，后者读取字符串数组属性中的第index个字符串。如drivers/clk/clk.c中的of_clk_get_parent_name()透过of_property_read_string_index()遍历clkspec结点的所有”clock-output-names”字符串数组属性。

1759 const char *of_clk_get_parent_name(struct device_node *np, int index)
1760 {
1761         struct of_phandle_args clkspec;
1762         const char *clk_name;
1763         int rc;
1764
1765         if (index < 0)
1766                 return NULL;
1767
1768         rc = of_parse_phandle_with_args(np, "clocks", "#clock-cells", index,
1769                                         &clkspec);
1770         if (rc)
1771                 return NULL;
1772
1773         if (of_property_read_string_index(clkspec.np, "clock-output-names",
1774                                   clkspec.args_count ? clkspec.args[0] : 0,
1775                                           &clk_name) < 0)
1776                 clk_name = clkspec.np->name;
1777
1778         of_node_put(clkspec.np);
1779         return clk_name;
1780 }
1781 EXPORT_SYMBOL_GPL(of_clk_get_parent_name);
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
处整形外、字符串以外的最常用属性类就是布尔类型，其对应的API如下

static inline bool of_property_read_bool(const struct device_node *np, const char *propname);
1
如果设备结点np含有propname属性，则返回true，否则返回false。一般用于检查空属性是否存在。

18.4.3 内存映射

void __iomem *of_iomap(struct device_node *node, int index);
1
通过设备结点直接进行设备内存区间的 ioremap()，index是内存段的索引。若设备结点的reg属性有多段，可通过index标示要ioremap的是哪一段，只有1段的情况，index为0。采用Device Tree后，大量的设备驱动通过of_iomap()进行映射，而不再通过传统的ioremap。

unsigned int irq_of_parse_and_map(struct device_node *dev, int index);
1
透过Device Tree或者设备的中断号，实际上是从.dts中的interrupts属性解析出中断号。若设备使用了多个中断，index指定中断的索引号。 
还有一些OF API，这里不一一列举，具体可参考include/linux/of.h头文件。

《Linux4.0设备驱动开发详解》笔记--第十九章：Linux电源管理的系统架构和驱动

《Linux4.0设备驱动开发详解》笔记--第二十章：Linux芯片级移植及底层驱动

《Linux4.0设备驱动开发详解》笔记--第二十一章：Linux设备驱动的调试

2016年05月21日 12:58:48 zcj仲从建 阅读数 647
 版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/z1106609486/article/details/51469968
21.1 GDB调式的方法

GDB的四个功能：

启动程序，可以按照工程师自定义的要求运行程序
让被调使得程序可以在指定的地方停住，断点可以是条件表达式
当程序停住时，可以检查此程序发生的事，并追踪上文
动态的改变程序的执行环境
调式内核和应用程序时调试的命令是相同的

基本命令

list命令（缩写l）：列出代码 
list ，显示程序第linenum行周围的源代码
list ，显示函数名为function的函数源程序
list，显示当前行前后的源程序
list -，显示当前行前面的源程序
run命令：运行程序
程序运行参数 
set args：指定运行时的参数，如set args 10 20 30
show args：查看设置好的运行参数
运行环境 
path
：设定程序的运行路径
how paths：查看程序的运行路径
set environment varname[=value]：设置环境变量，如set env USER=baohua;
show environment[varname]：查看环境变量
工作目录 
cd
：相当于shell的cd命令
pwd：显示当前所在的目录
程序的输入输出 
info terminal：显示程序用到的终端的模式
run>outfile：重定向控制程序输出
tty：指定输入的终端设备，如tty/dev/ttyS1
break命令 
break：在进入指定函数时停住
break：指定行号停住
break+offset/break-offset：当前 行号的前面或者后面offset行停住
break filename:linenum：在源文件filename的linenum行处停住
break filename:function：在源文件filename的function函数处停住
break*address：在程序运行的内存地址处停住
break：break命令没有参数时，表示在下一条指令处停住
beak…if：…可以是上述的break、break+offset/break-offset中的参数，condition表示条件，在条件成立时停住 
例如：在循环体中，可以设置break if i=100，表示当i为100时停住程序
info：查看断点，如info breakpoints[n]、info break[n]（n表示断点号）
单步命令 
step：单步跟踪，如果有函数调用，则进入该函数（进入该函数的前提是，此函数被编译有debug信息），默认一条条执行，加上count，执行后面count指令然后停止
next：单步跟踪，有函数则跳过，不加count，一条条执行，加上count则执行后面count条之后停住
set step-mode：set step-mode on用于打开step-mode模式 
在进行step时，若跨过某没有调试信息的函数，程序的执行会在该函数的第一条指令处停住，而不会跳过整个函数，这样可以查看该函数的机器指令
finish：运行程序，直到当前函数完成返回，并打印函数返回时的堆栈地址、返回值及参数值等信息
until（缩写为u）：一直在循环体内执行单步而退步出来是一件令人烦恼的事情，用until命令可以运行程序直到退出循环体
stepi(缩写为si)和nexti(缩写为ni)：这两个命里用于单步跟踪一条机器指令，step和next时C语言级别的命令 
运行display/i $pc命令之后，单步跟踪会在大厨程序代买的同时打出机器指令，即汇编代码
continue命令：当程序被停住后，可以用continue命令（缩写为c，fg命令同continue命令）恢复程序的执行直到程序结束，或到达下一个断点 
命令格式为：continue/c/fg [ignore-count]，ignore-count表示忽略其后多少次断点
例如：假设设置了函数断点add()，并观察i，则在continue过程中，每次遇到add()函数或者i发生变化，程序就会停住
print命令：再掉是程序时，当程序被停住时，可以使用print命令（缩写为p），或是同义命令inspect来查看当前程序的运行数据 
命令格式：print print / 其中是表达式，也是被调试的程序总的表达式，时输出的格式，比如，如果表达式按十六进制输出，则时/x 
表达式中，有几种GDB所支持的操作符，他们可以用在任何一种语言中 
@：是一个和数组有关的操作符
:: ：指定一个在文件或是函数中的变量
{}：表示一个指向内存地址的类型为type的对象
例1：演示了查看sum[]数组的值的过程
当需要查看一段连续内存空间的值时，可以使用GDB的@操作符，@的左边是第一个内存地址，@的右边是想查看内存的长度 
例2：动态申请内存
输出格式： 
x：十六进制
d：十进制
u：按十六进制，显示无符号整型
o：八进制
t：二进制
a：十六进制
c：字符格式
f：浮点数格式
display命令：设置一些自动显示的变量，当程序停住时，或是单步跟踪时，这些变量会自动显示
修改变量：print 变量=值
当GDB的print查看程序运行时的数据时，每个print都会被GDB记录下来。GDB会以1，1，2，$3。。。这样的方式为每一个print命令编号，可以用这个编号访问前面的表达式
watch命令：观察某个表达式（变量也是一种表达式）的值是否有了变化，有则马上停止运行 
watch：为表达式expr设置一个观察点，一旦这个表达式发生了变化则停止运行
rwatch：当表达式（变量）被读时，停止程序执行
awatch：当表达式（变量）的值被读或者被写时，停止运行
info watchpoints：列出当前所设置的所有观察点
examine命令：查看内存地址中的值 
语法：x/
**//例1：**
(gdb) print sum
$2 = {133, 155, 0, 0, 0 ,0 ,0 ,0 ,0 ,0}
(gdb) next

Breakpoint 1, main () at gdb-example.c:25
25         sum[i] = add(array1[i], array2[i]):
(gdb) next
23         for(i = 0; i< 10; i++)
(gdb) print sum
$3 = ({133, 155, 143, 0, 0 ,0 ,0 ,0 ,0 ,0}

//例2：
int *array = (int *) malloc (len * sizeof(int));
在GDB调试过程中个，这样实现这个动态数组的值：
p *array@len

//例3：
main()
{
    void *p = malloc(16);
    while(1);
}
//用如下命令来修改p指向的内存
(gdb) set *(unsigned char *)p='h'
(gdb) set *(unsigned char *)p='e'
(gdb) set *(unsigned char *)p='l'
(gdb) set *(unsigned char *)p='l'
(gdb) set *(unsigned char *)p='e'
//查看结果
（gdb） x/s p
0x804b008 "hello"
//查看函数func反汇编代码
(gdb) disassemble func
Dump of assembler code for function func:
0x8048450 <func>:    push  %ebp
0x8048451 <func+1> mov   %esp,%ebp
...
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
21.2 内核调试

21.2.1 内核打印信息—-printk()

内核打印语句printk()会将内核信息输出到内核信息缓冲区中，内核缓冲区时候在kernel/printk.c中通过以下语句静态定义： 
内核缓冲区是一个环形缓冲区（Ring Buffer），如果消息过多，则会将之前的消息冲刷掉
static char __log_buf[__LOG_BUF_LEN] __aligned(LOG_ALIGN);
1
printk()的8个消息级别，分别是0~7，级别越低（数值越大），消息越不重要，0级时紧急事件级，7级时调试级

#define KERN_EMERG “<0>”：紧急事件，一般是系统崩溃前的提示信息
#define KERN_ALERT “<1>”：必须立即采取行动
#define KERN_CRIT “<2>”：临界状态，通常涉及严重的硬件或软件操作失败
#define KERN_ERR “<3>”：用于报告错误状态，设备驱动程序会经常调用KERN_ERR来报告来自硬件的问题
#define KERN_WARNING “<4>”：对可能出现问题的情况进行警告，这类情况通常不会对系统造成严重的问题
#define KERN_NOTICE “<5>”：有必要进行提示的正常情形，许多与安全相关的状况用这个级别进行汇报
#define KERN_INFO “<6>”：内核提示信息，很多驱动程序在启动的时候，用这个级别打印他们找到的硬件信息
#define KERN_DEBUG “<7>”：用于调试
通过/proc/sys/kernel/printk文件可以调节printk()的输出等级，该文件有4个等级

控制台日志级别：当前的打印级别，优先级高于该值的信息将被打印纸控制台
默认的信息日志级别：将用该优先级来打印没有优先级前缀的消息，也就是直接写printk(“xxx”)而不带打印级别的情况下，会用该级别打印
最低的控制台日志级别：控制台日志级别可被设置的最小值（一般都是1）
默认的控制台日志级别：控制台日志级别的默认值 
例5：Ubuntu上的输出级别
//例5：Ubuntu上的输出级别
$ cat /proc/sys/kernel/printk
4   4   1   7
1
2
3
显示内核打印信息方法

通过dmesg命令，如果使用dmesg -c命令，则不仅会显示__log_buf，还会清除该缓冲区的内容
使用cat /proc/kmsg 命令，/proc/kmsg是一个“永无休止的文件”，因此，cat /porc/kmsg的进程只能通过“Ctrl+C”或kill终止
设备驱动中的调试函数

pr_debug()，pr_info() 
使用pr_xxx()族API的好处是，可以在文件开头通过pr_fmt()定义一个打印格式
例6：在kernel/watchdog.c的最开头通过如下定义可以保证之后watchdog.c调用的所有pr_xxx()打印的消息都自动带有“NMI watchdog: ”的前缀
dev_debug()：如dev_dbg()、dev_err()、dev_info()等 
使用dev_xxx()族API打印的时候，设备名称会被自动加到打印消息的前头
打印的附加信息，例7 
func：输出printk()调用所在的函数名
LINE：输出其所在的代码行
FILE：输出源代码命令名
//pr_debug()与pr_info()定义
#ifdef DEBUG
#define pr_debug(fmt,arg...) \
    printk(KERN_DEBUG fmt,##arg)
#else
static inline int __attribute__ ((format (printf,1,2))) pr_debug(cost char * fmt, ...)
{
    return 0;
}
#endif

#define pr_infor(fmt,arg ...) \
    printk(KERN_INFO fmt, ##arg)
1
2
3
4
5
6
7
8
9
10
11
12
13
//例6:
#define pr_fmt(fmt) "NMI watchdog: " fmt

#include <linux/mm.h>
#include <linux/cpu.h>
#include <linux/nmi.h>
...
//例7：
printk(KERN_ERR "Assertion failed! %s,%s,%s,line=%d", #expr, __FILE__, __func__, LINE);
1
2
3
4
5
6
7
8
9
21.2.2 DEBUG_LL和EARLY_PRINTK

DEBUG_LL对应内核的Kernel low-level debugging功能，EARLY_PRINTK对应内核中一个早起的控制台 
为了在内核的drivers/serial下的控制台驱动初始化之前支持打印，可以选择上述两个配置项，另外需要在bootargs中设置earlyprintk的选项
21.2.3 使用“/proc”

“/proc”是一个虚拟文件系统，通过它可以在Linux内核空间和用户控件之间进行通信 
在“/proc”文件系统中，可以将对虚拟文件的读写作为与内核中实体进行通信的一种手段，这些虚拟文件的内容都是动态的
“/proc”下的绝大多数文件是只读的，以显示内核信息为主，也不都是只读，如修改/proc/sys/kernel/printk以改变printk()的打印级别
Linux系统的许多命令本身都是通过分析”/proc”下的文件来完成的，如ps、top等，例如，free命令通过分析/proc/meminfo文件的到可用内存信息
21.2.4 Oops

内核出现类似用户空间的Segmentation Fault时，Oops会被打印到控制台和写入内核log缓冲区 
反汇编一个目标文件：arm-linux-gnueabihf-objdump -d -s xxx.o
21.2.5 BUG_ON()和WARN_ON()

内核中许多地方调用类似BUG()的语句，它非常像一个内核运行时的断言，以为这本来不该执行到BUG()这条语句，一旦执行到即跑出Oops 
BUG()语句定义如下： 
panic()定义在kernel/panic.c中，会导致内核崩溃，并打开Oops
#define BUG()  do { \
    printk("BUG: failure at %s:%d/%s()!\n", __FILE__, __LINE__, __func__"); \
    panic("BUG!");
}while(0)
1
2
3
4
BUG_ON()：时BUG()的变体，只有当括号内的条件成立的时候，才抛出Oops
WARN_ON()：在括号里的条件成立的时候，内核会抛出栈回溯，但是不会panic()，这通常用于内核抛出一个警告，暗示某种不太合理的事情发生了
21.2.8 strace

strace是个有效的跟踪工具，它的主要特点是可以被用来监视系统调用 
既可以调试一个新开始的程序，也可以调试一个已经在运行的程序（这意味着把strace绑定到一个已有的PID上）

